# 第12章 Java内存模型与线程

> JMM定义了Java虚拟机在内存中的工作方式，是对特定的内存和高速缓存进行读写访问的过程抽象。

## 12.2 硬件效率与一致性

> 1.一致性问题
>
> 2.乱序执行问题

由于计算机加入一层读写速度尽可能接近处理器计算速度的高速缓存来作为内存与处理器之间的缓冲。于是就引入了一个新的问题：缓存一致性。再多处理器系统中，每个处理器都有自己的高速缓存，同时它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将导致各自的缓存数据不一致。

![截屏2020-04-20下午4.13.09](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-20下午4.13.09.png)

除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化。处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一样的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此如果一个计算任务以来另外一个计算任务的中间结果，那么其顺序性不能靠代码的先后顺序来保证。

## 12.3 Java内存模型

### 12.3.1 主内存与工作内存

Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程也不能直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成。

![截屏2020-04-20下午4.31.22](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-20下午4.31.22.png)

### 12.3.2 内存间交互操作

Java内存模型定义了8种操作来规范主内存与工作内存之间的同步细节，这些操作都是原子的，不可再分的。

1.lock(锁定)：作用于主内存变量

2.unlock(解锁):作用于主内存变量

3.read(读取):作用于主内存变量

4.load(载入):作用于工作内存的变量

5.use(使用):作用于工作内存的变量

6.assign(赋值):作用于工作内存的变量

7.store(存储):作用于工作内存的变量

8.write(写入):作用于主内存的变量

### 12.3.3 对于volatile变量的特殊规则

当一个变量被定义为volatile之后，它具备两种特性，第一是保证变量对所有线程的可见性。可见性是指当一个线程修改了这个变量的值，新值对于其他线程来说是立即可见的。第二是使用volatile禁止指令重排序优化。

volatile通过添加内存屏障的方式实现。所谓内存屏障就是cpu对内存访问过程中的一个同步点，使得所有屏障之前的操作都执行完成并刷入主存后屏障之后的操作才可以执行。

### 12.3.4 对于long和double型变量的特殊规则

允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，因此如果有多个线程共享一个未声明为volatile的long或者double类型的变量，并且同时对他们进行读取和修改操作，那么某些线程可能会读到一个既非原值，也不是其他线程修改的数值，但这个现象非常少见。

### 12.3.6 先行发生原则

先行发生是Java内存模型中定义的两个操作之间的关系，如果说A先行发生B，其实就是在说操作B之前，操作A产生的影响能被B观察到。

Java内存模型定义了一些天然的先行发生关系：

1.程序次序原则：在一个线程中，按照程序代码顺序。

2.管程锁定：unlock先行发生后面的lock。

3.volatile变量规则：对一个volatile变量的写操作先行发生之后的对这个变量的读操作。

4.线程启动规则：start方法先行发生于此线程的每一个动作。

5.线程终止原则：线程中所有的操作都先行发生于对线程的终止检测。

6.线程中断规则

7.对象终结规则

8.传递性规则

## 参考资料

[参考资料](https://www.jianshu.com/p/8a58d8335270)

