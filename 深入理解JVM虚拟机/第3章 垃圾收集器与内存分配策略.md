# 第3章 垃圾收集器与内存分配策略

## 垃圾回收算法

### 引用计数算法

​		给对象中添加一个引用计数器，每当有一个地方引用它时，引用计数器加一，当引用失效时，计数器减一，任何时候计数器为0的对象就是不会再被使用的。但是它很难解决对象之间循环引用的问题。

### 可达性分析算法

​		算法的基本思想是通过一系列“GC ROOT”对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC ROOT没有任何引用链相连，则证明此对象是不可用的。	

​		可以用作GCROOT的起点包括：

1.虚拟机栈中引用的对象。

2.方法区中类静态属性引用的变量。

3.方法区中常量引用的对象。

4.Native方法引用得对象。

### 标记-清除算法

​		首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。他的主要不足有两个：1.效率不高。2.空间问题标记清除后会产生大量不连续的内存碎片，导致无法找到足够的连续内存而不得不触发另一次垃圾收集动作。

### 复制算法

​		他可以按照容量将内存划分为两部分，每次只使用其中一部分。当这一块内存用完了，便将存活的对象复制到另一块，再将这一块完全清理。因此不需要考虑内存碎片问题，缺点是利用率不高。

### 标记-整理算法

​		复制收集算法在对象存活率较高的时会进行较多的复制操作，效率降低。标记整理算法仍然是先对对象进行标记，然后让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法

​		将Java堆分为新生代和老年代，新生代存活比例低，采用复制算法，老年代一般采用标记整理或者标记清除算法。



## 引用

强引用：只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象，即使抛出OutOfMemory异常。

软引用：软引用用来描述一些还有用但非必须的对象，对于软引用关联的对象，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用得对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

弱引用：也是用来描述非必需的对象，强度比软引用更弱，只能活到下次垃圾收集之前。且垃圾收集器工作时，无论当前内存是否足够，都会回收被弱引用关联的对象。

虚引用：最弱的引用关系，完全不会对对象的生存时间构成影响，也无法通过虚引用取得实例。唯一目的就是在对象被回收时候收到一个系统通知。

引用队列：引用队列可以和软引用和弱引用一起使用，如果所引用的对象被回收，就会把这个引用加入到与之关联的引用队列中。虚引用必须要和引用队列联合使用。

## 垃圾收集器

### Serial/Serial Old收集器

单线程收集器，简单快速。但是在工作时候必须停止其他所有工作线程，直至回收结束。Serial采用复制算法，Serial Old采用标记整理算法。

![截屏2020-04-23上午11.07.18](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.07.18.png)

### ParNew收集器

Serial收集器的多线程版本。这里指的是垃圾收集时候是多线程的，也会停止其他工作线程，采用复制算法。

![截屏2020-04-23上午11.07.42](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.07.42.png)

### Parallel Scavenge/Parallel Old收集器

新生代收集器，多线程。特点是可以控制吞吐量。以降低垃圾收集时间，提升用户代码运行时间为目标。Parallel采用复制算法，Parallel Old采用标记整理算法。
$$
吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）
$$
![截屏2020-04-23上午11.29.41](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.29.41.png)

### CMS收集器

CMS是一种以获取最短回收停顿时间为目标的收集器，CMS以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。只将那些必需STW才能执行的操作单元单独拎出来，控制这些单元在恰当的时机运行，并能保证仅需短暂的时间就可以完成。这样，在整个收集周期内，只有**两次短暂的暂停（初始标记和重新标记）**，**达到了近似并发的目的**。使用标记-清除算法整个过程分为4步：

1.初始标记：标记GC ROOT关联的对象，STW

2.并发标记：进行GC ROOT TRACING，

3.重新标记：修正并发标记期间标记改变，STW

4.并发清除：清除标记对象

缺点：

1.CPU敏感，虽然不会造成停顿，但是会占用资源导致程序变慢。

2.无法处理浮动垃圾：由不STW，清理阶段的新产生的垃圾无法清理，存在浮动垃圾。

3.标记-清除算法实现的收集器会产生碎片。

![截屏2020-04-23上午11.39.13](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.39.13.png)

### G1收集器

G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个region区域，每个region区都是逻辑上的一段连续内存，每个角色的区域个数是不固定的，提升灵活性。这么做的目的是在进行收集时不必在全堆范围内进行。具有以下特点：

1.并行与并发：充分利用多CPU，通过并发的方式，不影响Java程序继续运行。

2.分代收集：能够不需要其他收集器配合独立管理堆。

3.空间整合：整体看来是标记-整理算法的，不会产生空间碎片。

4.可预测的停顿：通过实时跟踪Region区垃圾堆积的价值大小，同时有一个根据之间数据维护的垃圾收集模型来预测每个region区域的手机时间，在指定收集时间内优先回收价值高的Region，在有限的时间内提升收集效率。

![截屏2020-04-23上午11.48.47](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.48.47.png)

G1收集器的收集步骤包括：

- **初始标记（Initial Marking）**：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，**这阶段需要`停顿线程`，但耗时很短**。
- **并发标记（Concurrent Marking）**：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，**这阶段耗时较长**，但可与用户程序并发执行。
- **最终标记（Final Marking）**：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，**这阶段需要`停顿线程`，但是可并行执行**。
- **筛选回收（Live Data Counting and Evacuation）**：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。



## 安全点

​		安全点，即程序执行时并非在所有阶段都可以进行停顿下来开始GC，只有到达安全点时才可以暂停。安全点的目的是找到一个虚拟机堆栈不会发生变化的稳定状态，能够执行可达性分析。	

​		对于安全点，需要考虑的问题是如何在GC发生时让所有线程都运行到最近的安全点。主要有两种方式：

1.抢占式中断：抢占式中断不需要线程的执行代码主动去配合，在GC发生时首先中断全部线程，如果有线程不在安全点上，便重启线程使它执行到安全点上。

2.主动式中断：当GC需要中断线程的时候，不需要直接中断线程，而是设置一个标识位，每个线程在安全点上轮询标识位，如果发现标识位被设置，则中断挂起。



## 空间分配与回收策略

> 年轻代分为两个区域：Eden区和Survivor区(两个），默认比例8:1。

### 3.6.1 空间优先在Eden分配

​		大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配的时候，虚拟机将发起一次Minor GC

### 3.6.2 大对象直接进入老年代

​		所谓的大对象是指，需要大量连续内存的Java对象，最典型的就是很长的字符串以及数组。使用`-XX:PreteenurseSizeThreshold`参数控制大于这个值的对象直接进入老年代分配，这样做避免在年轻代进行大量内存复制。

### 3.6.3 长期存活的对象进入老年代

​		刚进入Survivor区的对象年龄为1，每过一次Minor GC，年龄增加一岁。通过`-XX:MaxTenuringThreshold`设置进入老年代阈值，默认15.

### 3.6.4 动态对象年龄判定

​		并不是永远低要求对象的年龄必须达到阈值才能进入老年代。如果survivor空间中相同的年龄所有对象的大小综合大于survivor空间的一半，年龄大于或者等于该年龄的对象可直接进入老年代。

### 3.6.5 空间分配担保

​		在发生Minor GC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间。如果条件成立，则可以确保Minor GC是安全的，如果不成立，则检查`HandlePromotionFailure`设置的值是否允许担保失败，如果允许，则检查老年代连续空间是否大于历次进入老年代对象的平均大小，如果大于尝试Minor GC。如果小于或者`HandlePromotionFailure`不允许冒险，则发生Full GC。
