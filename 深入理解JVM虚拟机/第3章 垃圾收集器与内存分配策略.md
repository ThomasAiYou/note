# 第3章 垃圾收集器与内存分配策略

## 垃圾回收算法

### 引用计数算法

​		给对象中添加一个引用计数器，每当有一个地方引用它时，引用计数器加一，当引用失效时，计数器减一，任何时候计数器为0的对象就是不会再被使用的。但是它很难解决对象之间循环引用的问题。

### 可达性分析算法

​		算法的基本思想是通过一系列“GC ROOT”对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC ROOT没有任何引用链相连，则证明此对象是不可用的。	

​		可以用作GCROOT的起点包括：

1.虚拟机栈中引用的对象。

2.方法区中类静态属性引用的变量。

3.方法区中常量引用的对象。

4.Native方法引用得对象。

### 标记-清除算法

​		首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。他的主要不足有两个：1.效率不高。2.空间问题标记清除后会产生大量不连续的内存碎片，导致无法找到足够的连续内存而不得不触发另一次垃圾收集动作。

### 复制算法

​		他可以按照容量将内存划分为两部分，每次只使用其中一部分。当这一块内存用完了，便将存活的对象复制到另一块，再将这一块完全清理。因此不需要考虑内存碎片问题，缺点是利用率不高。

### 标记-整理算法

​		复制收集算法在对象存活率较高的时会进行较多的复制操作，效率降低。标记整理算法仍然是先对对象进行标记，然后让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法

​		将Java堆分为新生代和老年代，新生代存活比例低，采用复制算法，老年代一般采用标记整理或者标记清除算法。



## 引用

强引用：只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

软引用：软引用用来描述一些还有用但非必须的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之卡没，会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够内存，才会跑出内存溢出异常

弱引用：也是用来描述非必需的对象，强度比软引用更弱，只能活到下次垃圾收集之前。且垃圾收集器工作时，无论当前内存是否足够，都会回收导致被弱引用关联的对象。

虚引用：最弱的引用关系，完全不会对对象的生存时间构成影响，也无法通过虚引用取得实例。唯一目的就是在对象被回收时候收到一个系统通知。



## 垃圾收集器

### Serial/Serial Old收集器

单线程收集器，简单快速。但是在工作时候必须停止其他所有工作线程，直至回收结束。

![截屏2020-04-23上午11.07.18](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.07.18.png)

### ParNew收集器

Serial收集器的多线程版本。这里指的是垃圾收集时候是多线程的，也会停止其他工作线程。

![截屏2020-04-23上午11.07.42](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.07.42.png)

### Parallel Scavenge/Parallel Old收集器

新生代收集器，多线程。特点是可以控制吞吐量。以降低垃圾收集时间，提升用户代码运行时间为目标。
$$
吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）
$$
![截屏2020-04-23上午11.29.41](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.29.41.png)

### CMS收集器

CMS是一种以获取最短回收停顿时间为目标的收集器，使用标记-清除算法整个过程分为4步：

1.初始标记：标记GC ROOT关联的对象，STW

2.并发标记：进行GC ROOT TRACING，

3.重新标记：修正并发标记期间标记改变，STW

4.并发清除：清除标记对象

缺点：

1.CPU敏感，虽然不会造成停顿，但是会占用资源导致程序变慢。

2.无法处理浮动垃圾：由不STW，清理阶段的新产生的垃圾无法清理，存在浮动垃圾。

3.标记-清除算法实现的收集器会产生碎片。

![截屏2020-04-23上午11.39.13](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.39.13.png)

### G1收集器

G1是一款面向服务器端的垃圾收集器，具有以下特点：

1.并行与并发：充分利用多CPU，通过并发的方式，不影响Java程序继续运行。

2.分代收集：能够不需要其他收集器配合独立管理堆。

3.空间整合：整体看来是标记-整理算法的，不会产生空间碎片。

4.可预测的停顿：通过实时跟踪Region区垃圾堆积的价值大小，根据收集时间优先回收价值高的Region，在有限的时间内提升收集效率。

![截屏2020-04-23上午11.48.47](/Users/denakira/Desktop/myworkspace/note/深入理解JVM虚拟机/picture/截屏2020-04-23上午11.48.47.png)



## 空间分配与回收策略

> 年轻代分为两个区域：Eden区和Survivor区(两个），默认比例8:1。

### 3.6.1 空间优先在Eden分配

​		大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配的时候，虚拟机将发起一次Minor GC

### 3.6.2 大对象直接进入老年代

​		所谓的大对象是指，需要大量连续内存的Java对象，最典型的就是很长的字符串以及数组。使用`-XX:PreteenurseSizeThreshold`参数控制大于这个值的对象直接进入老年代分配，这样做避免在年轻代进行大量内存复制。

### 3.6.3 长期存活的对象进入老年代

​		刚进入Survivor区的对象年龄为1，每过一次Minor GC，年龄增加一岁。通过`-XX:MaxTenuringThreshold`设置进入老年代阈值，默认15.

### 3.6.4 动态对象年龄判定

​		并不是永远低要求对象的年龄必须达到阈值才能进入老年代。如果survivor空间中相同的年龄所有对象的大小综合大雨survivor空间的一半，年龄大于或者等于该年龄的对象可直接进入老年代。

### 3.6.5 空间分配担保

​		在发生Minor GC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间。如果条件成立，则可以确保Minor GC是安全的，如果不成立，则检查`HandlePromotionFailure`设置的值是否允许担保失败，如果允许，则检查老年代连续空间是否大于历次进入老年代对象的平均大小，如果大于尝试Minor GC。如果小于或者`HandlePromotionFailure`不允许冒险，则发生Full GC。

