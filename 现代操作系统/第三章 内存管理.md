# 第三章 内存管理

## 3.1 无存储器抽象

​		最简单的存储器抽象就是根本没有抽象，每一个程序都直接访问物理内存。

​		没有存储器抽象的系统中实现并行的一种方式是使用多线程来编程，因为在引入线程的时候就假设一个进程中的所有线程对同一内存映像都可见。但不支持多线程并行，因此并不能同时运行没有关联的程序。

​		但即使没有存储器抽象，同时运行多个程序也是可能的。操作系统只需要把当前内存中所有内容保存到磁盘文件中，然后再把下一个程序读入到内存中再运行即可。

## 3.2 一种存储器抽象：地址空间

### 3.2.1 地址空间的概念

> 解决多个应用程序同时处于内存中并且相互影响的问题.

​		地址空间是一个进程可用于寻址内存的一套地址集合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。

**基地址寄存器与界限寄存器**

​		使用动态重定位方法可以简单的把每个进程的地址空间映射到物理内存的不同部分。所使用的经典办法是给每个CPU配置两个特殊硬件寄存器，通常叫做基地址寄存器和界限寄存器。程序装载到内存中连续的空闲位置并且装载期间无需重定位。程序的起始地址装载到基址寄存器中，程序的终止地址装载到界限寄存器中。



### 3.2.2 交换技术

> 解决所有进程需要RAM总和远超过存储器能够支持的范围(内存超载)。

​		有两种解决内存超载的通用方法。最简单的策略是交换，即把一个进程完整调入内存，使该进程运行一段时间，然后把它回磁盘。另一种是虚拟内存，该策略甚至能够使程序在只有一部分被调入内存的情况下运行。

**内存紧缩** 

​		交换在内存中产生了多个空闲区(也称为空洞)，通过把进程尽可能向下移动有可能将这些小的空闲区合成一个大块。该技术称为内存紧缩。

​		如果进程的数据段可以增长，就会出现问题。若进程与一个空闲区相邻，就可以把该空闲区分配给进程。若不空闲则需要把进程移动到较大的空闲区域中去。另一种方法是在分配内存的时候多分配一些额外的内存以便内存增长。



### 3.2.3 空闲内存管理

​		在动态分配内存时，操作系统必须对其进行管理。一般而言有两种方法跟踪内存使用情况：位图和空闲区链表。

**使用位图的存储管理**

> 每个分配单元对应于位图中的一位，0表示空闲，1表示占用。

​		分配单元的大小是一个重要的设计因素，分配单元越小，位图越大。但若进程的大小不是分配单元的整数倍，最后一个分配单元中就有一定的内存被浪费了。

​		这种方法的主要问题是，在准备把一个占k个分配单元的进程调入内存中时，存储器必须搜索位图，找到有k个连续0的串，这是相当耗时的操作。

**使用链表的存储管理**

> 维护一个已分配内存段和空闲内存段的链表。

​		当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以用来为创建进程分配内存。

1.首次适配算法：沿着链表进行搜索，直到找到一个足够大的空闲区。除非空闲区大小和要分配空间大小一样，否则分为两部分，一部分供进程使用，另一部分为空闲区。

2.下次适配：工作方式与首次适配相同，不同的是每次找到空闲区都记录当前位置，下次搜索时从当前位置开始。

3.最佳适配：最佳适配算法搜索整个链表，找出能够容纳进程的最小空闲区。

4.最差适配算法：为了防止分裂出非常多非常小的空闲区，总是分配最大的可用空闲区，使新的空闲区比较大从而可以继续使用。

5.快速适配：为那些常用大小的空闲区维护单独的链表。

​		如果进程和空闲区使用不同的链表，则可以按照大小对空闲区链表进行排序以便提高效率。



## 3.3 虚拟内存

> 交换技术对于内存不能满足程序需求这个问题来说并不是一个具有吸引力的解决方案，因为磁盘传输速率的限制，交换时间过长。

**虚拟内存**

​		虚拟内存的基本思想是：每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称作页面或者一页。每一页有连续的地址范围，这些页被影射到物理内存，但并不是所有页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分立刻装入物理内存并重新执行失败的指令。

### 3.3.1 分页

大部分虚拟内存系统中都使用一种称为分页的技术。

​		由程序产生的地址称为虚拟地址，在使用虚拟内存的情况下，虚拟地址不是直接被送到内存总线上，而是被送到内存管理单元(Memory Management Unit,MMU)，MMU负责把虚拟地址映射为物理内存地址

​		虚拟地址空间按照固定大小划分成被称为页面的若干单元，在物理内存中对应的单元被称为页框，页面和页框的大通常相等。当程序访问内存时，MMU将虚拟内存地址转换为映射后的物理内存地址。如果该页面没有被映射，于是CPU陷入到操作系统，这个trap被称为缺页中断。操作系统找到一个很少使用的页框并把他的内容写入磁盘，随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。

![截屏2020-04-11上午10.54.35](/Users/denakira/Desktop/myworkspace/note/现代操作系统/picture/截屏2020-04-11上午10.54.35.png)



### 3.3.2 页表

> 页表是MMU中虚拟地址到物理地址映射关系的一种简单实现。

​		虚拟地址可以被分成虚拟页号(高位部分)和偏移量(低位部分)两部分。例如对于16位地址和4KB的页面大小，高4位可以指定虚拟页面中的一页，而低12位能够确定所选页面中的字节偏移量。

​		虚拟页号可以用作页表的索引，找到该虚拟页面对应的页表项。由页表项可以找到页框号。然后把页框项拼接到偏移量的高位端，以替换掉虚拟页号，形成真正的物理地址。

### 3.3.3 加速分页过程

> 任何分页系统中都需要考虑两个问题:
>
> 1,虚拟地址到物理地址的映射必须非常快。
>
> 2.如果虚拟地址空间很大，页表也会很大。

**加速分页**

1.转换检测缓冲区：

> 大多数程序总是对少量的页面进行多次的访问。

​		因此解决方案是为计算机设置一个小型的硬件设备，将常用的虚拟地址直接映射到物理地址，而不必再访问页表。这种设备被称为转换检测缓冲区(TLB)或相连存储器或者快表。



### 3.3.4 针对大内存的页表

1.多级页表

引入多级页表的原因就是避免把全部页表一直保存在内存中。   

![截屏2020-04-11下午12.06.21](/Users/denakira/Desktop/myworkspace/note/现代操作系统/picture/截屏2020-04-11下午12.06.21.png)

2.倒排页表

​		在这种设计中，实际内存中的每个页框对应一个表项，而不是每个虚拟页面对应一个表项。虽然倒排页表节省了大量空间，但是从虚拟地址到物理地址的转换会变得复杂，必须搜索整个倒排页来找到一个表项（hash算法可改进）

## 3.4 页面置换算法

### 3.4.1 最优页面置换算法

> 如果知道程序运行和页面访问的所有情况，将之后最后访问的页面置换出去是最优算法。但基本不可能实现。

### 3.4.2 最近未使用页面置换算法

> 将页面分为4类：
>
> 1.没有被访问，没有被修改。
>
> 2.没有被访问，被修改。
>
> 3.被访问，没有被修改。
>
> 4.被访问，被修改

NRU(Not Recently Use) 每次从编号最小的非空集合挑选一个页面置换出去。

### 3.4.3 先进先出页面置换算法

> FIFO队列

### 3.4.4 第二次机会

> 在FIFO算法上添加标志位，每个页面有两次机会。

### 3.4.5 时钟页面置换算法

> 环形FIFO队列，可以减少但链表节点移动的开销。

### 3.4.6 最近最少使用页面置换算法

> LRU算法理论上是可以实现的，但是代价很高，每次都需要更新链表。

### 3.4.7 工作集置换算法

> 设置时间窗口t，在每次访问内存的时候，置换出时间窗口中没有使用的页面。缺页时换入页面，更新访存链表。

### 3.4.8 缺页率置换算法

> 设置时间窗口T，计算两次缺页间隔t>T,说明缺页率较低，置换出所有在t区间内没有使用过的页面。若t>T,说明缺页率较高，则直接换入页面。

