# Http & Https

## Http

### 1. 定义

​		HTTP协议即超文本传输协议(HyperText Transfer Protocol)，是互联网数据传输的基础，是作用在TCP基础上的应用层协议。定义了数据传输的内容和规范。

### 2.报文

#### 请求报文

​		HTTP的请求报文由3部分组成（请求行+请求头+请求体）

![截屏2020-08-24 上午10.18.23](/Users/denakira/Desktop/myworkspace/note/计算机网络/picture/截屏2020-08-24 上午10.18.23.png)

#### 响应报文

​	响应报文也由三部分组成（响应行+响应头+响应体）

![截屏2020-08-24 上午10.19.23](/Users/denakira/Desktop/myworkspace/note/计算机网络/picture/截屏2020-08-24 上午10.19.23-8235578.png)

### 3. 请求方法及区别

#### 请求方法：

**get**：请求指定的页面信息，获取资源。

**post**：上传指定资源提交数据进行处理请求。

**put**：从客户端向服务器传送的数据取代指定的文档的内容。

**delete**:删除指定页面

**connect**：预留给能够将连接改为管道方式的代理服务器。

**trace**：回显服务器收到的请求

**head**：类似于get请求，不过在返回的响应中没有具体请求的内容，用于获取报头

**options**：允许客户端查看服务器性能。



#### get方法和post方法区别：

1.适用场景：get方法适用于从服务器端获取数据，post方法适用于向服务器提交数据。

2.参数位置：get方法的参数在url的query中，post方法在content中

3.参数大小：get方法参数在url中，因此参数大小受限于url大小。

4.缓存：get方法可以被浏览器缓存，而post方法不能被缓存。



#### put方法和post方法区别：

put方法和post方法的区别在于put是幂等的而post不是幂等的，因此post经常用于添加资源而put用于在服务器更新资源。



### 4. Http的缓存机制

> Http的缓存机制是根据报文的缓存标识位来进行识别的。

​		当浏览器向服务器发起请求后拿到响应报文，会根据响应报文中Http头的缓存标识来决定是否缓存结果，如果是则将请求结果和缓存标识存储到缓存中。再次访问同样的地址的时候，根据是否要向服务器再次发送请求将缓存分为两部分：强制缓存和协商缓存。

#### 强制缓存

​		强制缓存就是向缓存查找该请求结果，并根据该结果的缓存规则来确定是否使用该缓存结果的过程。强制缓存分为3种情况：

1.不存在该缓存结果：直接向服务器发起请求。

2.存在该缓存结果和缓存标识，但是结果已经失效：此时转入协商缓存阶段。

3.存在该缓存结果和缓存标识，结果有效：直接返回该结果。



**强制缓存字段**

​		控制强制缓存的字段有两个分别为Expires和Cache-Control。Cache-control具有高优先级，Expires就是过期时间。Cache-control具有5种状态：

1.public：客户端和代理服务器都可以缓存。

2.private：只有客户端可以缓存。

3.no-cache：客户端缓存，但是是否使用缓存需要协商缓存决定。

4.no-store：不被缓存。

5.max-age：失效时间。



#### 协商缓存

​		协商缓存就是强制缓存失效后浏览器携带缓存标识向服务器发起请求，由服务器决定是否使用缓存的过程。

1.协商缓存生效：返回304状态码，直接使用缓存结果。

2.协商缓存失效：直接返回200和请求结果。



[参考资料]: https://www.cnblogs.com/chengxs/p/10396066.html



### 5.Http的版本区别

#### Http 1.1 VS Http 1.0

1. 长连接：Http1.1引入了长连接，就是TCP连接默认是不关闭的，可以被多个请求复用。客户端或者服务器长时间发现对方没有活动就会关闭连接，或者手动关闭连接，对于同一个域名支持6个长连接。
2. header头域：Http 1.1 支持只发送header信息，如果服务器认为客户端有权请求服务器则返回100，否则返回401。并且支持请求部分内容，当客户端已经有一部分资源了，只需要向服务器请求另外一部分资源即可，是断点续传的基础。
3. host域：Http1.1增加了host处理，因此允许一台物理服务器上存在多个虚拟主机，共享同一个ip地址，使用host域进行区分。



#### Http 2.0 VS Http 1.1

1. 多路复用：Http2.0支持同一个连接并发处理多个请求，采用连接共享机制，每个request对应一个id，一个连接可以根据request id同时处理多个请求。

 	2. header压缩：对于header域里面携带了大量信息，每次都要重新发送，2.0通过通信双方都各自缓存一份header表，避免重复header的传输。减少传输大小。
 	3. 服务器推送：当对服务器请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，这样客户端就不需要再为此重新发送请求，比如请求style.css会顺便推送style.js的信息。



### 6. 常用状态码

![截屏2020-08-31 下午3.05.21](/Users/denakira/Desktop/myworkspace/note/计算机网络/picture/截屏2020-08-31 下午3.05.21.png)

		1. 200：OK。
  		2. 301：请求资源移动到新的位置。
  		3. 304：客户端缓存是最新的，确认使用缓存。
  		4. 404:：客户端请求资源不存在。
  		5. 500：服务器错误。



## HTTPS

### 1.定义

> Https实在Http基础上通过加密传输和身份验证来表征传输过程中的安全性。Https在Http基础上添加了SSL层，为数据安全提供支持。

### 2.传输步骤

1. 首先建立TCP三次握手，这是数据传输的基础，在此之上开始SSL通信。

 	2. 客户端首先发送Client Hello开始SSL通信，报文中包含支持的SSL版本，加密算法等信息。
 	3. 服务器端发送Server Hello，报文中也包含SSL版本，加密组件等信息，同时发送自己的证书到客户端。
 	4. 客户端对服务器端发送的证书进行验证。通过操作系统内置的CA证书，将服务器发送的证书的数字签名进行解密，验证证书的合法性。
 	5. 客户端验证证书合法性后，产生随机密钥R，通过公钥对R进行加密然后发送client-key-exchange报文交换密钥，然后发送change-cipher-space报文表示以后数据进行加密传输。
 	6. 服务器端用自己的私钥解密得到R，发送change-cipher-space报文表示数据将进行加密传输。
 	7. 接下来两端传输的消息分别使用R进行加密传输。

[参考资料]: https://www.cnblogs.com/WindrunnerMax/archive/2020/03/27/12580585.html

