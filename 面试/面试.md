# 面试 

## JVM

### 1.运行时的数据区域

答：JVM运行时数据区域大致分为5部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区。java8之后本地方法区变成了metaspace，放入了堆中。

​		程序计数器主要记录执行的字节码行号等信息，方便指令跳转。虚拟机栈是线程私有的，执行方法时创建栈帧存储局部变量，操作数，方法出口等信息。本地方法栈和虚拟机栈差不多，不过是为本地方法服务的。堆主要保存对象的实例。方法区主要保存类的信息，常量等。

### 2.垃圾回收机制

答：垃圾回收主要是在堆上，对于对象的实例分为新生代和老年代。同时新生代又分为1个Eden区域和2个Survivor区域，单个Eden：Survivor=8:1。新创建的对象主要生成在Eden区域，然后minor gc采用复制算法，达到一定次数以后进入老年区。

### 3.垃圾回收算法

答：主要垃圾回收算法包括：1.引用计数法；2.可达性分析法；3.标记-清理法；4.标记-整理法；5.复制法；6.分代收集法。

### 4.Minor GC和Full GC触发条件

答：Minor GC作用于新生代，当无法为新对象分配空间时发生Minor GC。Full GC是老年代，1.调用system.gc()；2.空间分配担保失败时候发生Full GC；3.新进大对象进入老年代超过内存大小发生

### 5.GC ROOT的起点都可以包括什么

答：1.虚拟机栈中直接引用的对象；2.方法区中类静态变量和常量引用的对象；3.本地方法栈中JNI（即一般说的native方法）引用的对象

### 6.GC中的STW(stop the world)

答：stop the world 是指JVM运行过程中，除了垃圾收集线程，其他线程都被挂起的情况。Serial收集器，CMS收集器都会发生这种情况。

### 7.各个垃圾回收器的特点和区别

答：Serial/Serial Old收集器是单线程收集器，特点是简单快速，但是gc时会发生STW；ParNew收集器是Serial收集器的多线程版本，指垃圾收集是多线程的，也会发生STW，主要用于配合CMS收集器用作新生代收集器。Parallel/Parallel OLD 可控吞吐量。CMS最短时间为目标的老年代收集器分为4步初始标记、并发标记、重新标记、并发清除。除了初始标记和重新标记STW剩下多线程执行。缺点是CPU敏感、无法处理浮动垃圾、会产生碎片(标记清除)。G1收集器具有并发，分代，整合，可预测的特点，监控每个region，在有限时间收集价值最高的垃圾。

### 8.什么是Java内存模型

答：Java内存模型定义了JVM操作虚拟机时的工作方式，是对内存进行读写访问的过程抽象。

### 9.Java内存模型存在什么问题

答：Java每个线程都有单独的工作内存，他们不能够直接操作主存，因此会有线程之间的可见性问题，并且因为编译器会进行代码优化，所以也会有指令重排的问题。

### 10.volatile关键字是怎么实现的

答：volatile关键字是通过内存屏障来实现变量的可见性和防止指令重排。每次读volatile变量的时候都会使本地的工作内存无效化，直接从主存拷贝副本。每次写volatile变量都会立刻刷新到主存之中。

### 11.怎么理解内存屏障

答：内存屏障可以看作多线程之间的同步点，内存屏障之前的操作必须都进行完毕，并将变量值刷入主存后才能执行之后的内容，并且内存屏障内的代码不允许指令重排。

### 12.说几个先行发生原则

答：1.程序次序原则；2.管程锁定原则；3.volatile变量原则；4.线程启动原则

### 13.类加载过程

答：过程如下：

1.加载：主要是指通过类的全限定名称来获取定义此类的二进制字节流。

2.验证：验证的目的是为了确保字节流中包含的信息符合当前虚拟机的要求。

3.准备：正式为类变量分配内存，并设置类变量初始值的阶段。

4.解析：解析是虚拟机将常量池内的符号引用转换为直接引用的过程。

5.初始化：开始正式执行类中定义的Java程序代码。

6.使用：

7.卸载：

### 14.双亲委派模型和优点

答：类加载器分为3类，分别是启动类加载器，扩展类加载器和应用程序类加载器。双亲委派模型要求除了启动类加载器外，剩下的类加载器都应当有自己的父类加载器。如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是委派给父类加载器去完成，只有父类无法完成时，子类加载器才会尝试自己去加载。

**优点**

1.防止同一个类被重复加载，保证安全性。

2.保证核心的类不能被更改。

**如何打破**

答：如果不想打破双亲委派模型，就重写ClassLoader类中的findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写loadClass()方法。

### 15. sychronized关键字是怎么实现的

答：

## SQL

### 1.SQL执行流程

![截屏2020-04-23下午4.39.11](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-23下午4.39.11-7631167.png)

答：1.客户端通过TCP连接发送连接请求到MySql连接器，连接器会对该请求进行权限验证以及连接资源分配。2.客户端发送一条语句，如果是select语句，在开启查询缓存的情况下，首先在查询缓存中查找该SQL是否完全匹配。3.如果在查询缓存中没有匹配成功，则将语句交给分析器做词法分析和语法分析。4.分析器分析的之后进入优化器，比如多个索引如何选择索引等。5.执行器调用引擎的接口，并返回调用的结果。

### 2.SQL的分类

答：SQL语句主要可以划分为以下三个类别：

1.DDL(Data Definition Languages)语句：数据定义语言。

2.DML(Data Manipulation Language)语句：数据操纵语句。

3.DCL(Data Control Language)语句：数据控制语句。

### 3.事务的基本要素

答：ACID。A：原子性，所有操作都是原子操作。C：一致性，事物必须保持系统处于一致的状态。I：隔离性，保证事物之间是相互隔离的。D：事务完成之后，便被持久化到磁盘之中，不会被更改。

### 4.事物的隔离级别

答：Read Uncommitted，Read Committed，Repeated Read, Serializable

### 5.InnoDB和MyISAM的区别

答：MyISAM和InnoDB都是MySQL的存储引擎。区别主要在MyISAM不是事务安全的，没有外键，且MyISAM只支持表锁。InnoDB支持事物和行锁。同时MyISAM和InnoDB的索引也有所不同，MyISAM使用的是非聚集索引，InnoDB使用的聚集索引。

### 6.MVCC

答：MVCC的目的是并发访问数据库时，对正在事务内处理的数据做多版本的管理。以达到用来避免写操作的拥塞。利用当前读和快照读的方式来解决幻读等问题。

### 7.Join语句中on和where条件的区别

答：on是在表连接的时候起作用，where是生成连接表之后再对连接表进行过滤。

### 8. 数据库三大范式

答：第一范式：确保每列保持原子性，数据库表中的每列都是不可分解的原子值。第二范式：保证每列都和主键相关。第三范式：确保每列都和主键直接相关，而不能间接相关。



## 多线程

### 1.线程的几种状态

答：线程有6种状态，分别是:New:刚刚创建的线程、Runnable:准备就绪、Waiting:无时间限制等待、Blocked:被阻塞，比如synchronized同步块、Timed_waiting限时等待和Terminated:结束。

### 2.线程创建的方式

答：线程创建有三种方式：

1.继承Thread类，重写run方法，使用start()方法来启动线程。

2.实现Runnable接口，重写run方法，使用start()方法来启动线程。

3.通过Callable和Future创建线程，实现Callable接口，实现call()方法

### 3.线程池的种类

答：为了避免频繁的创建和销毁线程，让线程复用可以创建线程池。线程池主要有以下几种：

1.newFixedThreadPool:返回一个固定数量的线程池。

2.newSingleThreadExecutor:返回一个只有一个线程的线程池。

3.newCachedThreadPool:返回一个可以根据实际情况调整线程数量的线程池。

4.newSingleThreadScheduledExecutor和newScheduledThreadPool:扩展了在给定时间执行任务的功能。

### 4.线程池的内部实现

答：上面的线程池都是ThreadPoolExecutor的封装类。

![截屏2020-04-24下午3.32.43](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-24下午3.32.43.png)

任务队列：

1.直接提交队列：每来一个任务都直接提交，超过了最大线程数量，执行拒绝策略。

2.有界任务队列：ArrayBlockingQueue来实现的，有最大容量限制。

3.无界任务队列：LinkedBlockingQueue来实现的，无最大容量限制。

4.优先级队列：PriorityBlockingQueue来实现，根据任务优先级来执行。

拒绝策略：

1.AbortPolicy策略：该策略直接抛出异常，阻止系统正常运行。

2.CallerRunsPolicy：只要线程池未关闭，直接在调用者线程中，运行当前任务。提交线程性能下降。

3.DiscardOldest:抛弃最老的请求。

4.DiscardPolicy：抛弃无法处理的这个请求。

### 5.线程池个数

答：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目。

如果是CPU密集型应用，则线程池大小设置为N+1。因为cpu密集型应用频繁切换上下文，会带来额外的开销。

如果是IO密集型应用，则线程池大小设置为2N+1。IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间

### 6.wait和sleep的区别

答：sleep属于Thread类，表示让一个线程进入睡眠状态，等待一段时间以后自动唤醒，没有释放锁。wait属于object，释放了锁，如果设置了超时时间并不需要其他线程使用notify方法也能解除阻塞。否则需要调用notify方法。

### 7.并行和并发的区别

答：并发是指一个处理器同一时刻只能执行一条指令，但是多个任务快速切换，给人们一种同时执行的感觉，是逻辑上的同时发生。并行是指多个处理器同时执行多条指令，是物理上的同时发生。



## 计算机网络

### 1.HTTP请求方法

答：Http有八种请求方法分别是：GET：请求页面信息、HEAD：获取报头、POST：提交数据进行请求处理、PUT：传送数据、DELETE：删除指定页面、CONNECT预留能将连接改为管道方式的代理服务器、OPTIONS：查看主机性能、TRACE：显示服务器收到的请求，用于诊断。

### 2.键入URL对应过程

答：过程如下：

1.客户端连接到HTTP服务器：浏览器与WEB服务器的HTTP端口(默认是80端口)建立TCP套接字连接。

2.发送HTTP请求：通过TCP套接字，客户端向服务器发送请求报文，包括请求行、请求头部、空行和请求数据4部分。

3.服务器接受请求并返回HTTP相应：WEB服务器解析请求，定位资源，将资源副本写到TCP套接字，返回响应。响应由状态行、响应头部、空行和响应数据4部分组成。

4.释放TCP连接：

5.客户端浏览器解析响应内容，在浏览器窗口显示。

### 3.常用状态码

答：200:OK、404:NOT FOUND，资源不存在、400:BAD REQUEST，参数无效、403:FORBIDDEN客户端错误

### 4.TCP三次握手和四次挥手

答：ACK：确认序号， SYN：发起链接，FIN：释放链接

**三次握手**

![截屏2020-06-02 下午3.29.06](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-02 下午3.29.06.png)

1.客户端向服务器端发送TCP报文，标记位为SYN，表示请求链接。

2.服务器端返回一段报文，标志位为SYN和ACK，表示收到报文，并确认创建链接。

3.客户端发送确认报文，标志位为ACK。完成SYN-SENT阶段，开始正常数据传输。

**为什么要进行第三次握手**

答：首先服务器端的资源比较宝贵，第三次握手是为了防止服务器端的资源被浪费。比如第二阶段的报文丢失，超过了超时时间，客户端又重新发送新建链接的报文，此时第一次的服务器端口就一直开着被占用，造成严重的浪费。又比如已经超时的第一阶段报文到达服务器，而此时服务器以为是有效请求，同样开启端口。因此为了减少服务器端的开销，需要三次握手。

**四次挥手**

![截屏2020-06-02 下午3.50.05](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-02 下午3.50.05.png)

1.客户端想要释放链接，发送报文，标记位为FIN，进入FIN-WAIT阶段。

2.服务器端收到报文后回复ACK报文，进入CLOSE-WAIT阶段。

3.当服务器端准备好释放链接后，发送报文，标记位为FIN和ACK，表示准备好释放链接，进入LAST-ACK阶段。

4.客户端回复ACK报文，标记位为ACK，进入TIME-WAIT 2MSL阶段。服务器端收到最后的报文后关闭链接。

**为什么握手是三次，挥手却要四次**

答：TCP连接建立的时候之所以只要三次握手是因为在第二次的过程中，服务器端发送给客户端的报文同时包括了ACK和SYN标志位，是再一次握手中传输的。断开连接的时候之所以需要四次挥手，是因为FIN和ACK是分两次进行传输的，因为服务器在收到释放链接请求的时候不能立即释放，还有数据需要处理，因此服务器端首先回复ACK报文，再在准备好之后回复FIN释放链接，因此需要四次挥手。

**为什么客户端在TIME-WAIT要等2MSL**

答：为的是确认服务器端收到客户端第四阶段的ACK报文。MSL指的是一段TCP报文最大的生命周期。如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。

[](https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc)

### 5. TCP如何确保可靠传输

答：

**数据的合理分片和排序**

1.校验和：TCP保持一个端到端的校验和，目的是检测数据在端到端的传输中是否有变化。

2.确认和重传：每次接收方接收到数据后，都会对传输方进行确认应答。因此如果长时间没有收到响应报文，就会启动重传机制。

3.流量控制：TCP连接的每一方，都会有固定大小的buffer，当接收方的缓冲区大小不够来不及及时处理发送方的数据，能提示发送方降低发送速率，防止包丢失，对应TCP来说是使用的可变大小的滑动窗口。

4.拥塞控制：当网络发生阻塞的时候，减缓发送速率。慢开始（指数增长），拥塞避免（线性增长），快重传（收到三个重复确认直接重传），快恢复（恢复后不是从1开始）

### 6.Post和Put的区别

答：Post操作既不是安全幂等的，Put操作是安全和幂等的。

### 7.粘包现象

答：首先TCP是一个基于字节流的传输控制协议，因此并不存在包的概念。广义上的TCP粘包现象是指发送方发送的数据到达接收方缓冲区后没有被正确及时的处理，导致不同应用没有处理好字节流之间的分割，导致“粘包”现象的发生。

### 8.网络的七层模型

答：OSI的7层模型分别是：应用层(HTTP)，表示层，会话层，传输层(TCP,UDP)，网络层，数据链路层和物理层。

### 9. HTTP和HTTPS的区别

答：HTTP是超文本传输协议，是一个基于请求与响应，无状态的应用层协议。HTTPS是一种经由HTTP进行通信，利用SSL/TLS进行加密处理的安全通信传输协议。

## JAVA

### 1.ArrayList和LinkedList区别

答：区别如下：

1.ArrayList是基于数组的数据结构，LinkedList是基于链表的数据结构。

2.对于随机访问的方法ArrayList优于LinkedList，因为数组支持随机访问，LinkedList要移动指针。

3.对于插入删除数据操作LinkedList要优于ArrayList，因为ArrayList要移动数据。

### 2.Exception的父类，几种错误

![截屏2020-04-24下午4.18.42](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-24下午4.18.42.png)

### 3.锁

1.公平锁/非公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的顺序来获得锁。公平锁的好处是线程不会饿死，但效率较低一些。因为非公平锁某时刻可能不需要唤醒线程，抢占。

2.重入锁：如果当前线程已经拥有了对象的锁，只需要把锁的计数器+1，便可以直接进入临界区，避免一定程度避免死锁的出现。

3.重量级锁：Java线程要映射到操作系统原生线程之上，因此如果阻塞和唤醒线程需要从用户态转到核心态。因此需要这种转换的锁称为重量级锁。

4.偏向锁：偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步(不需要CAS与内存中的预期值进行比较)。

按照竞争条件分为：无锁 < 偏向锁 < 轻量级锁 < 重量级锁



### 4.Hash

答：Hash就是把任意长度读输入，通过散列算法，变成固定长度的输出，该输出就是散列值。

**Hash冲突的处理方式**

答：Hash冲突的处理方法有以下几种：

​		1.开放地址法(线性探查)：当冲突发生时候，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个序列一次查找下去，当碰到一个空单元的时候，插入其中。

​		2.拉链法：冲突发生的时候，使用链表存储散列值相同的元素。

​		3.建立公共溢出区域：把冲突放在另一个公共溢出区中。

​		4.再Hash方法：计算散列值方法不止一个，如果有冲突发生再次计算散列值。



### 5. HashMap

答：HashMap的底层实现是数组+链表结构，当链表长度达到一定长度的时候链表会转化为红黑树，HashMap不是线程安全的。

**1.HashMap的key和value可以为空值吗**

​		HashMap的key和value均可以为空值。（注：HashTable的key和value都不能为空）

**2.HashMap的扩容机制**

​		HashMap的初始默认负载因子(load_factor)为0.75，初始默认大小为16.当结点个数大于负载因子*容量大小的时候发生扩容。

**3.扩容为什么是2的倍数**

​		HashMap是使用(n-1)&hash的方法计算元素在数组中的位置，这里的n就是HashMap的数组长度，因此如果n是2的倍数，n-1就能保证除了最高位剩下的都是1，这样在与hash值计算的时候就能够充分散列，最大程度上避免散列冲突。

![截屏2020-04-25上午10.08.53](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午10.08.53.png)

**4.HashMap是如何实现Hash算法的**

​		首先算出hashCode右移16位做异或运算(相同为0不同为1)

![截屏2020-04-25上午9.25.12](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午9.25.12.png)

**5.红黑树转换**

​		当某一链表长度binCount >= TREEIFY_THRESHOLD - 1的时候进入treeifyBin方法。但是此时并不一定进行扩容，因为在treeifyBin方法中还要对数组长度进行判断，当数组长度小于MIN_TREEIFY_CAPACITY(默认64)的时候不会进行转换。

![截屏2020-04-25上午9.44.05](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午9.44.05.png)

**6.多线程操作HashMap会造成什么问题**

​		因为HashMap不是线程安全的因此当多线程操作HashMap扩容的时候会造成循环链表的的问题。

**7.如何避免多线程问题的产生**

​		如果知道元素个数，可以初始化长度，并且将负载因子设置为1，这样可以有效避免扩容的出现。

**8.为什么选择8作为转化红黑树的阈值**

​		因为hash算法服从泊松分布，当单一链表超过8的时概率小于百万分之一。



### 6.HashMap、HashTable、ConcurrentHashMap

答：HashTable是线程安全的，实现方式是在操作上加上sychronized关键字，因此会锁整张表，效率较低。HashMap是线程不安全的。ConcurrentHashMap是线程安全的。在Java8之前ConcurrentHashMap时使用分段锁来实现并发的，数据结构为hashMap的基础上再套一层segment数组，锁加在segment数组元素上。Java8实现了更加细粒度的锁，去掉了segment数组，直接使用synchronized锁住了hash后得到的数组下标位置中的第一个元素。这样比segment锁支持更高的并发度。

### 7.transient关键字

答：使用transient关键字修饰的属性不能再被序列化。

### 8. set是如何保证key不会重复的

答：最常用的HashSet的底层是使用HashMap来实现的，HashMap保证了key的唯一性。

### 9.final和static

**final**

答：final修饰类，表示这个类不能被继承。final修饰方法，表示这个方法不能被子类重写。final修饰变量，表示这个变量的引用不能被改变，但这个引用如果是一个对象，对象的内容可以被改变。

**static**

答：static修饰变量，该变量会生成在内存堆上，该变量与对象无关，被类控制，所有对该变量的引用都指向同一内存地址。static修饰代码块，在类初次被加载的时候，会按照static块的顺序，执行每个static块。static修饰方法的时候，可以使用类名.方法名直接调用方法，不需要实例化对象，但仅可以访问类的静态变量。static可以修饰内部类对象，这样内部类对象可以作为一个普通类来使用，不需要实例化外部类对象。

```java
 1 public class OuterClass {
 2     public static class InnerClass{
 3         InnerClass(){
 4             System.out.println("============= 我是一个内部类'InnerClass' =============");
 5         }
 6     }
 7 }
 8 
 9 
10 public class TestStaticClass {
11     public static void main(String[] args) {
12         // 不需要new一个InnerClass
13         new OuterClass.InnerClass();
14     }
15 }
```

### 10. equal、==、和hashcode

答：==在比较基本数据类型的时候比较的是值是否相等，在比较引用类型的变量的时候比较的是内存的地址。equal方法在没有重写的情况下比较的是地址是否相同，如果进行了重写，比较的一般是两个对象的内容是否相同。equals方法和hashcode方法都是继承自object类，重写了equal方法后，最好也要重写hashcode方法，否则在使用hashmap等集合的时候，逻辑上相等的两个对象可能出现存储两次的情况。equal相等hashcode相等，hashcode不等equals不等，hashcode相等推不出equal相等。

### 11. 基本数据类型

![截屏2020-06-03 下午3.48.36](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-03 下午3.48.36.png)

### 12. Int和Integer区别

答：Integer是Int的包装类，Int是java的一种基本数据类型。int和integer在进行比较的时候，integer会自动进行拆箱，两个int值进行比较。两个integer进行比较，关键在于是否创建了对象。满足两种条件会创建对象：1.使用`new integer()`2.值的范围超过`[-128,127]`。如果没有创建对象会缓存在IntegerCache中，此时进行比较就会相等。

```java
				Integer i1 = 128;
        int i2 = 128;
        System.out.println(i1 == i2); //True

        Integer i3 = 127;
        Integer i4 = 127;
        System.out.println(i3 == i4); //True

        Integer i5 = 128;
        Integer i6 = 128;
        System.out.println(i5 == i6); //False

        Integer i7 = 127;
        Integer i8 = new Integer(127); //False
        System.out.println(i7 == i8);
```

[]:https://blog.csdn.net/wangyang1354/article/details/52623703

### 13. fail-fast和fail-safe区别

答：当使用迭代器遍历集合元素的时候，如果使用了除迭代器本身方法以外的其他方法改变集合的结构，则会抛出ConcurrentModificationException异常。这是因为迭代器在执行next()等方法的时候会执行checkForComodification()检查。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。这就是fail-fast

```java
final void checkForComodification() {
		if (modCount != expectedModCount)
    		throw new ConcurrentModificationException();
}
```

而fail-safe不会抛出异常，原因在于当集合结构被改变的时候，fail-safe机制会在原集合的基础上复制一份数据出来，然后在复制出来的数据上面继续遍历。

[]:https://www.cnblogs.com/kubidemanong/articles/9113820.html

### 14. String、StringBuilder和StringBuffer

答：这三个类的主要区别在运行速度和线程安全性

速度比较：StringBuilder > StringBuffer > String:因为String是final类且为字符串常量，因此一旦创建就不能被更改，所以String的操作实际上是不断创建然后回收对象的过程，因此在运行速度上很慢。而StringBuilder和StringBuffer的区别主要在与线程的安全性，StringBuffer中的大部分方法是有sychronized关键字进行修饰的，因此是线程安全的。但相较于StringBuilder来说性能上会受到一些影响。



## 操作系统

### 1. 进程与线程

**进程与线程的区别**

1.进程是资源分配的最小单位，线程是资源调度的最小单位。

2.进程有自己独立的地址空间，每启动一个进程，系统都将为它分配地址空间。而线程是共享进程中的数据的，使用相同的地址空间。因此线程切换一个进程和创建一个进程的花费远高于线程。

**进程间通信方式**

1.管道：在内核中申请一段固定大小的缓冲区，程序拥有写入和读取的权利。

2.消息队列：在内核中创建一个队列，队列中的每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。

3.信号量

4.共享内存：将同一块物理内存映射到不同进程的虚拟地址空间之中，实现不同进程对同一内存的访问。

5.socket：用于不同机器之间的通信。

**线程间通信方式**

互斥量、读写锁、条件变量。

### 2.用户态与内核态

​		用户态和内核态是操作系统的两种运行级别，当程序运行在R3特权级别的时候可以称为运行在用户态，在R0级别的时候可以成为运行在内核态。在用户态的级别只能访问受限的内存，且不允许访问外围IO设备等，只能使用非特权指令。而在内核态级别下可以访问内存中所有数据，包括外围IO设备。

​		应用程序大部分都是运行在用户态的状态之下，如果需要操作系统帮助完成某些在用户态完成不了的操作，便可以切换到内核态。用户态切换到内核态主要包括三种方式：

1.系统调用：操作系统在内核里都有一些内建的函数，这些函数可以完成一些系统级别的功能。比如fork指令调用的是sys_fork 

2.异常：当cpu在执行用户态的程序的时候发生了一些事先不可知的异常，则会切换到处理此异常的内核相关程序中，比如缺页异常。

3.外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，此时CPU会停止执行下一条指令而去处理中断，那么这个转换的过程就发生了由用户态向内核态的切换。

### 3. fork

​		fork是linux中用来创建与父进程相同的子进程的系统调用函数，它创建了一个原有进程的精确副本，包括所有文件描述符、寄存器等全部内容。



## Linux

### 1. chmod

​		chmod命令是用来更改文件权限的，分为三种权限：

1.写：w，权限值4

2.读：r，权限值2

3.执行：x，权限值1

其中按顺序分别表示，user、group和other的权限。例如：chmod741 表示user具有读写执行的权限，group具有写权限，other具有执行权限。

### 2.Linux 查看CPU和内存情况

​		top命令是Linux下常用的性能分析工具，能够显示系统中各个进程的资源占用情况。显示内容包括：用户占CPU百分比，内核占CPU百分比，空闲CPU，物理内存总量，使用内存总量等。

![img](https://img2018.cnblogs.com/blog/720994/201809/720994-20180918152552123-1390484337.png)

