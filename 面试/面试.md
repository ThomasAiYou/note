# 面试 

## JVM

### 运行时的数据区域

​	JVM运行时数据区域大致分为5部分：

1. 程序计数器：程序计数器主要记录正在执行的字节码行号等信息，用于指令跳转。
2. 虚拟机栈：虚拟机栈是线程私有的，执行方法时创建栈帧用于存储局部变量、操作数、方法出口等信息。
3. 本地方法栈：本地方法栈与虚拟机栈差不多，只不过是为本地方法服务的。
4. 堆：堆主要保存对象的实例。
5. 方法区：方法区存储类的信息，静态变量，常量等。



### Java内存模型

​		Java内存模型定义了java虚拟机在操作内存时候的工作方式，是对内存进行读写访问过程的抽象。Java内存模型规定所有变量都要存在主存中，而每个线程都有自己的工作内存，不能够直接操作主存中的数据。



### volatile和内存屏障

​		volatile关键字通过内存屏障来实现变量的可见性，同时防止指令重排。内存屏障可以看作是多线程之间的同步点，内存屏障之前的操作必须都执行完，且将变量刷入主存之后才能执行屏障之后的内容，且内存屏障之内的代码不允许指令重排。每次读volatile变量的时候都会使本地的工作内存无效化，直接从主存拷贝副本。每次写volatile变量都会立刻刷新到主存之中。



### 垃圾回收机制和垃圾处理算法

​		垃圾回收主要是在堆上，对于对象的实例分为新生代和老年代。同时新生代又分为1个Eden区域和2个Survivor区域，单个Eden：Survivor=8:1。新创建的对象主要生成在Eden区域，达到一定次数以后进入老年区。

​		垃圾处理算法包括：

1. 标记清理法。
2. 标记整理法。
3. 复制算法。
4. 分代收集算法



### GC ROOT起点和标记算法

​		GC Root起点包括：

1. 虚拟机栈中直接引用的对象。

2. 本地方法栈中引用的对象。

3. 方法区中静态变量。

4. 方法区中常量。

   标记算法包括：

1. 引用计数法。
2. 可达性分析法。



### Minor GC和Full GC触发条件

​		Minor GC作用于新生代，当无法为新对象分配空间时发生Minor GC。Full GC是老年代gc，

1. 调用system.gc()。
2. 空间分配担保失败时候发生Full GC。
3. 新进大对象进入老年代超过内存大小发生。



### 垃圾回收器的特点和区别

1. Serial/Serial Old收集器是单线程收集器，特点是简单快速，但是gc时会发生STW。
2. ParNew收集器是Serial收集器的多线程版本，指垃圾收集是多线程的，也会发生STW，主要用于配合CMS收集器用作新生代收集。
3. Parallel/Parallel OLD 可控吞吐量。
4. CMS最短时间为目标的老年代收集器分为4步初始标记、并发标记、重新标记、并发清除。除了初始标记和重新标记STW剩下多线程执行。缺点是CPU敏感、无法处理浮动垃圾、会产生碎片(标记清除)。
5. G1收集器具有并发，分代，整合，可预测的特点，监控每个region，在有限时间收集价值最高的垃圾。



### 类加载过程

1. 加载：主要是指通过类的全限定名称来获取定义此类的二进制字节流。

2. 验证：验证的目的是为了确保字节流中包含的信息符合当前虚拟机的要求。

3. 准备：正式为类变量分配内存，并设置类变量初始值的阶段。

4. 解析：解析是虚拟机将常量池内的符号引用转换为直接引用的过程。

5. 初始化：开始正式执行类中定义的Java程序代码。

6. 使用：

7. 卸载：



### 双亲委派模型

​		类加载器分为3类，分别是启动类加载器，扩展类加载器和应用程序类加载器。双亲委派模型要求除了启动类加载器外，剩下的类加载器都应当有自己的父类加载器。如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是委派给父类加载器去完成，只有父类无法完成时，子类加载器才会尝试自己去加载。

**优点**

1.防止同一个类被重复加载，保证安全性。

2.保证核心的类不能被更改。

**如何打破**

答：如果不想打破双亲委派模型，就重写ClassLoader类中的findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写loadClass()方法。



## 数据库

### MySQL执行流程

![截屏2020-04-23下午4.39.11](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-23下午4.39.11-7631167.png)

1. 客户端通过TCP连接发送连接请求到MySql连接器，连接器会对该请求进行权限验证以及连接资源分配。

2. 客户端发送一条语句，如果是select语句，在开启查询缓存的情况下，首先在查询缓存中查找该SQL是否完全匹配。
3. 如果在查询缓存中没有匹配成功，则将语句交给分析器做词法分析和语法分析。
4. 分析器分析的之后进入优化器，比如多个索引如何选择索引等。
5. 执行器调用引擎的接口，并返回调用的结果。



### SQL的分类

​		SQL语句主要可以划分为以下三个类别：

1. DDL(Data Definition Languages)语句：数据定义语言。

2. DML(Data Manipulation Language)语句：数据操纵语句。

3. DCL(Data Control Language)语句：数据控制语句。



### 事务的基本要素

​		事务有四个基本要素，分别是ACID：

1. A：原子性，所有操作都是原子操作。
2. C：一致性，事物必须保持系统处于一致的状态。
3. I：隔离性，保证事物之间是相互隔离的。
4. D：持久性，事务完成之后，便被持久化到磁盘之中，不会被更改。



### MySQL事务的隔离级别

​		MySQL有四种事务的隔离级别，分别是：

1. Read Uncommitted
2. Read Committed
3. Repeated Read
4. Serializable



### InnoDB和MyISAM的区别

​		MyISAM和InnoDB都是MySQL的存储引擎。区别主要在MyISAM不是事务安全的，没有外键，且MyISAM只支持表锁。InnoDB支持事务和行锁。同时MyISAM和InnoDB的索引也有所不同，MyISAM使用的是非聚集索引，InnoDB使用的聚集索引。



### MVCC

​		MVCC的目的是并发访问数据库时，对正在事务内处理的数据做多版本的管理。以达到用来避免写操作的拥塞。利用当前读和快照读的方式来解决幻读等问题。



### Join语句中on和where条件的区别

​		on是在表连接的时候起作用，where是生成连接表之后再对连接表进行过滤。



### 数据库三大范式

​		第一范式：确保每列保持原子性，数据库表中的每列都是不可分解的原子值。第二范式：保证每列都和主键相关。第三范式：确保每列都和主键直接相关，而不能间接相关。



### 什么是索引回表

​		非主键索引需要通过B+树获取id值后，进行回表，通过主键索引查找到对应数据。避免的话可以通过覆盖索引，就是第一次查找的时候就返回了所需要的数据。



### 谓词下推

​		优化SQL的一项基本技术是将外层查询块中的谓词移入所包含的较低层的查询块，从而能够更早地进行数据过滤，减少数据在分区之间传输的数据量。

```sql
select table1.name, table2.score
from table1 join table2 on table1.id = table2.id
where table1.age > 20 and table2.score > 90
```

```sql
select name, score
from(
  (select table1.id, table1.name from table1 where table.age > 20) t1
  join
  (select table2.id, table2.score from table2 where table2.score > 90) t2
  on t1.id = t2.id
)
```

![截屏2020-09-07 下午1.49.55](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-09-07 下午1.49.55.png)



### 缓存穿透、缓存击穿、缓存雪崩

  1. 缓存穿透：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求导致数据库压力过大产生的现象。解决方式：1. 接口增加校验，id做基础校验进行拦截。2. 布隆过滤器

  2. 缓存击穿：缓存击穿是指缓存中没有但数据库中存在的数据(一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库取数据，引起数据库压力瞬时增大。解决方式：1. 使用互斥锁 2.热点数据永不过期。

  3. 缓存雪崩：缓存雪崩是指缓存中数据大批量到达过期时间，而查询数据量巨大，引起数据库压力过大。缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。解决方式：1. 缓存过期时间设置随机，防止同一时间大量数据过期。

     [参考资料]: https://blog.csdn.net/kongtiao5/article/details/82771694



## 多线程

### 线程的几种状态

​		线程有6种状态，分别是:

1. New:刚刚创建的线程。
2. Runnable:准备就绪。
3. Waiting:无时间限制等待。
4. Blocked:被阻塞，比如synchronized同步块。
5. Timed_waiting限时等待
6. Terminated:结束。



### 线程创建的方式

​		线程创建有三种方式：

1. 继承Thread类，重写run方法，使用start()方法来启动线程。

2. 实现Runnable接口，重写run方法，使用start()方法来启动线程。

3. 通过Callable和Future创建线程，实现Callable接口，实现call()方法



### wait和sleep的区别

​		sleep属于Thread类，表示让一个线程进入睡眠状态，等待一段时间以后自动唤醒，没有释放锁。wait属于object，释放了锁，如果设置了超时时间并不需要其他线程使用notify方法也能解除阻塞。否则需要调用notify方法。



### 并行和并发的区别

​		并发是指一个处理器同一时刻只能执行一条指令，但是多个任务快速切换，给人们一种同时执行的感觉，是逻辑上的同时发生。并行是指多个处理器同时执行多条指令，是物理上的同时发生。



### notify和notifyall的区别

​		JVM会为使用锁的对象维护两个集合，锁池和等待池。

**锁池**：对于锁池来说，如果线程A持有了对象锁，此时有其他线程BC获取锁，则BC进入锁池，BC的线程状态为blocked。

**等待池**：如果线程A调用了wait，则线程A进入了等待池，并且线程处于waiting状态。

如果对象想要获得锁，有两个先决条件：1.持有锁的对象释放了锁。2.线程处于runnable状态。处于锁池的对象在锁被释放以后自动唤醒某一线程。处于等待池的对象必须要通过notify或者notifyall来唤醒，notify只能唤醒一个线程从锁池进入等待池，而notifyall可以换行所有对象进入锁池。复杂情况下notify可能产生死锁。

[参考资料]:(https://www.jianshu.com/p/25e243850bd2?appinstall=0)



### start方法和run方法

​		调用start方法可以启动线程，而run方法只是thread类里面一个普通方法，还是在主线程里面执行。



### ThreadLocal

​		ThreadLocal是一个线程内部的存储类，提供了线程内存储变量的能力，并且每一个线程读取的变量是相互独立的，能够做到线程安全。ThreadLocalMap是ThreadLocal的静态内部类，所有的方法都是private的，因此只有ThreadLocal能够进行操作。每个Thread都有一个TheadLocal.ThreadLocalMap对象，ThreadLocalMap的key就是ThreadLocal类型，value是Object类型。因此能够做到线程安全。



### 线程池

1. 定义。
2. Java中的线程池。
3. 线程池的实现。
4. 线程池的执行流程。
5. 线程复用底层原理：
   1. 线程池的状态。
   2. Worker类。
6. 相关知识：
   1. 线程池线程数量。
   2. shutDown()和shutDownNow()。
   3. 线程池ThreadLocal问题。



## 计算机网络

### Http & Https



### 键入URL对应过程

​		过程如下：

1. 输入URL，URL是指统一资源定位符。

2. 浏览器查找域名的IP地址（DNS协议）：请求一旦发起浏览器首先要做的就是解析这个域名，找到对应的ip地址。按照本地硬盘的hosts文件 -> 本地DNS服务器 -> 根DNS服务器 -> 域DNS服务器的顺序进行请求。

3. 浏览器向web服务器发送http请求：浏览器拿到域名对应的ip地址以后向服务器发起TCP连接请求

4. 服务器处理请求：后段会通过TCP连接进行处理，对HTTP协议进行解析，并按照格式封装成HTTP对象供上层使用。如果网站流量较大，会将同一个应用部署在多台服务器上，此时客户端不是通过HTTP协议直接访问网站服务器，而是通过nginx等反向代理服务器，nginx收到请求，再根据规则请求真正的应用服务器，最后将结果返回客户端。

5. 浏览器接收服务器返回结果并显示页面：浏览器接收HTTP响应，响应包括：状态行，响应头，响应正文。浏览器显示页面，完成一次对应过程。

[参考资料]:(https://blog.csdn.net/wlk2064819994/article/details/79756669)



### TCP三次握手和四次挥手

答：ACK：确认值，ack：确认编号， SYN：发起链接，FIN：释放链接, SEQ:顺序号码

**三次握手**

![截屏2020-06-02 下午3.29.06](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-02 下午3.29.06.png)

1.客户端向服务器端发送TCP报文，标记位为SYN，表示请求链接。

2.服务器端返回一段报文，标志位为SYN和ACK，表示收到报文，并确认创建链接。

3.客户端发送确认报文，标志位为ACK。完成SYN-SENT阶段，开始正常数据传输。

**为什么要进行第三次握手**

答：首先服务器端的资源比较宝贵，第三次握手是为了防止服务器端的资源被浪费。比如第二阶段的报文丢失，超过了超时时间，客户端又重新发送新建链接的报文，此时第一次的服务器端口就一直开着被占用，造成严重的浪费。又比如已经超时的第一阶段报文到达服务器，而此时服务器以为是有效请求，同样开启端口。因此为了减少服务器端的开销，需要三次握手。

**四次挥手**

![截屏2020-06-02 下午3.50.05](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-02 下午3.50.05.png)

1.客户端想要释放链接，发送报文，标记位为FIN，进入FIN-WAIT阶段。

2.服务器端收到报文后回复ACK报文，进入CLOSE-WAIT阶段。

3.当服务器端准备好释放链接后，发送报文，标记位为FIN和ACK，表示准备好释放链接，进入LAST-ACK阶段。

4.客户端回复ACK报文，标记位为ACK，进入TIME-WAIT 2MSL阶段。服务器端收到最后的报文后关闭链接。

**为什么握手是三次，挥手却要四次**

答：TCP连接建立的时候之所以只要三次握手是因为在第二次的过程中，服务器端发送给客户端的报文同时包括了ACK和SYN标志位，是再一次握手中传输的。断开连接的时候之所以需要四次挥手，是因为FIN和ACK是分两次进行传输的，因为服务器在收到释放链接请求的时候不能立即释放，还有数据需要处理，因此服务器端首先回复ACK报文，再在准备好之后回复FIN释放链接，因此需要四次挥手。

**为什么客户端在TIME-WAIT要等2MSL**

答：为的是确认服务器端收到客户端第四阶段的ACK报文。MSL指的是一段TCP报文最大的生命周期。如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。

[](https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc)



###  TCP如何确保可靠传输

1. 校验和：TCP保持一个端到端的校验和，目的是检测数据在端到端的传输中是否有变化。

2. 确认和重传：每次接收方接收到数据后，都会对传输方进行确认应答。因此如果长时间没有收到响应报文，就会启动重传机制。

3. 流量控制：TCP连接的每一方，都会有固定大小的buffer，当接收方的缓冲区大小不够来不及及时处理发送方的数据，能提示发送方降低发送速率，防止包丢失，对应TCP来说是使用的可变大小的滑动窗口。

4. 拥塞控制：当网络发生阻塞的时候，减缓发送速率。慢开始（指数增长），拥塞避免（线性增长），快重传（收到三个重复确认直接重传），快恢复（恢复后不是从1开始）

![截屏2020-08-09 下午3.12.52](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-08-09 下午3.12.52.png)

### 粘包现象

​		首先TCP是一个基于字节流的传输控制协议，因此并不存在包的概念。广义上的TCP粘包现象是指发送方发送的数据到达接收方缓冲区后没有被正确及时的处理，导致不同应用没有处理好字节流之间的分割，导致“粘包”现象的发生。



### 网络的五层模型和七层模型

​		OSI的7层模型分别是：应用层(HTTP)，表示层，会话层，传输层(TCP,UDP)，网络层，数据链路层和物理层。五层模型包括：应用层，传输层，网络层，数据链路层和物理层。



### Cookie、Session、Token

**Cookie和Session**

​		Cookie和Session是用来实现会话跟踪技术的。Cookie实际上是一小段文本信息（4k），如果服务器需要记录该用户状态，就向浏览器发送一个Cookie，客户端进行保存。Session是保存在服务器上，每个用户分配一个session_id，每次使用session_id进行查询。

区别在于：

1.Cookie存储在客户的浏览器上，Session存储在服务器上。

2.安全性：Cookie不是很安全。

3.服务器性能：Session会在一定时间保存在服务器上。当访问增多会占用服务器的性能。

4.数据：cookie大小不能超过4k，session没有数据量的限制，可以保存更加复杂的类型。

5.生存周期：session的生存周期较短，浏览器关闭或者定时结束。cookie可以永久保存。



**Session和Token**

​		Token是无状态的令牌。与cookie和session不同的是，token并不是用来进行会话跟踪的实现，而是用来对用户进行验证，只对用户的权限进行验证，并不会在服务器端保存用户的信息。token一般由uid(用户唯一标志) + time(时间戳) + sign(签名)组成，每次登陆对token进行校验，来验证用户权限。



### ARP协议

答：ARP协议是Address Resolution Protocol地址解析协议的缩写。其作用是在以太网的环境中，数据传输所依赖的是mac地址而不是IP地址，而将IP地址转换为mac地址的工作是由ARP协议来完成的。

**工作原理**：

在任何时候，当主机需要找出网络中的另一个主机的物理地址的时候，他就可以发送一个ARP请求报文，这个报文包装了发送方的MAC地址，发送方的IP地址，以及接收方的IP地址。这个报文会在网络层中进行广播。每一台主机都会接收并处理这个ARP请求报文，然后进行验证，查看接收方IP地址是不是自己的，只有验证成功的主机才会返回一个ARP响应报文，这个响应报文包含接收方的IP地址和mac地址。因此发送方就可以得到目标的mac地址。



### 单点登录

​		单点登录全称是Single Sign On，是指在多系统应用群中登录一个系统，便可以在其他所有系统中得到授权而无需再次登录。相比于其他登录系统，单点登录需要一个独立的认证中心，只有认证中心能够接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接收认证中心的间接授权。

[参考资料]: https://blog.csdn.net/xiaoguan_liu/article/details/91492110



## JAVA

### Java三个特性

1. 封装：封装就是把对象的属性和操作结合成一个独立的整体，并且尽可能隐藏对象内部的实现细节。
2. 继承：继承就是子类继承父类的特征和行为，使得子类对象具有父类对象的方法。
3. 多态：多态就是同一个行为具有不同的表现形式



### 泛型擦除

​		Java在编译期间所有泛型信息都会被擦掉，因为Java的泛型是在编译器层面实现的，在生成的字节码中是不包含泛型中类型信息的，在编写的时候加上类型参数，在编译的时候类型信息会被去掉，这个过程叫做泛型擦除。

### ArrayList和LinkedList区别

1. ArrayList是基于数组的数据结构，LinkedList是基于链表的数据结构。

2. 对于随机访问的方法ArrayList优于LinkedList，因为数组支持随机访问，LinkedList要移动指针。

3. 对于插入删除数据操作LinkedList要优于ArrayList，因为ArrayList要移动数据。



### Exception的父类，几种错误

![截屏2020-04-24下午4.18.42](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-24下午4.18.42.png)



### Hash

​		Hash就是把任意长度读输入，通过散列算法，变成固定长度的输出，该输出就是散列值。

**Hash冲突的处理方式**：

1. 开放地址法(线性探查)：当冲突发生时候，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个序列一次查找下去，当碰到一个空单元的时候，插入其中。

2. 拉链法：冲突发生的时候，使用链表存储散列值相同的元素。

3. 建立公共溢出区域：把冲突放在另一个公共溢出区中。

4. 再Hash方法：计算散列值方法不止一个，如果有冲突发生再次计算散列值。



### HashMap

​		HashMap的底层实现是数组+链表结构，当链表长度达到一定长度的时候链表会转化为红黑树，HashMap不是线程安全的。

**1.HashMap的key和value可以为空值吗**

​		HashMap的key和value均可以为空值。（注：HashTable的key和value都不能为空）

**2.HashMap的扩容机制**

​		HashMap的初始默认负载因子(load_factor)为0.75，初始默认大小为16。当结点个数大于（负载因子*容量大小）的时候发生扩容。

**3.扩容为什么是2的倍数**

​		HashMap是使用(n-1)&hash的方法计算元素在数组中的位置，这里的n就是HashMap的数组长度，因此如果n是2的倍数，n-1就能保证除了最高位剩下的都是1，这样在与hash值计算的时候就能够充分散列，最大程度上避免散列冲突。

![截屏2020-04-25上午10.08.53](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午10.08.53.png)

**4.HashMap是如何实现Hash算法的**

​		首先算出hashCode右移16位做异或运算(相同为0不同为1)

![截屏2020-04-25上午9.25.12](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午9.25.12.png)

**5.红黑树转换**

​		当某一链表长度binCount >= TREEIFY_THRESHOLD - 1的时候进入treeifyBin方法。但是此时并不一定进行扩容，因为在treeifyBin方法中还要对数组长度进行判断，当数组长度小于MIN_TREEIFY_CAPACITY(默认64)的时候不会进行转换。

![截屏2020-04-25上午9.44.05](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午9.44.05.png)

**6.多线程操作HashMap会造成什么问题**

​		因为HashMap不是线程安全的因此当多线程操作HashMap扩容的时候会造成循环链表的的问题。

**7.如何避免多线程问题的产生**

​		如果知道元素个数，可以初始化长度，并且将负载因子设置为1，这样可以有效避免扩容的出现。

**8.为什么选择8作为转化红黑树的阈值**

​		因为hash算法服从泊松分布，当单一链表超过8的时概率小于百万分之一。



### HashMap、HashTable、ConcurrentHashMap

​		HashTable是线程安全的，实现方式是在操作上加上sychronized关键字，因此会锁整张表，效率较低。HashMap是线程不安全的。ConcurrentHashMap是线程安全的。



### ConcurrentHashMap 1.7和1.8的区别

1. 整体结构：1.7使用的是Segment+HashEntry，1.8移除了segment，使锁的粒度更小，使用类似HashMap的Node+CAS+synchronized的形式。

2. put操作：1.7先定位segment再定位桶，put的全程加锁。没有获取锁的线程最多自旋64次，超过则挂起等待唤醒。1.8直接定位桶，为空则CAS插入，否则加锁put

3. size操作：1.7计算两次size看看是否相等，这种操作最多重复三次。如果还是不想等则对每个segment加锁，再计算。1.8使用volatile类型的baseCount来记录元素的个数。



### set是如何保证key不会重复的

​		最常用的HashSet的底层是使用HashMap来实现的，HashMap保证了key的唯一性。



### TreeSet和HashSet的区别

​		TreeSet的底层是TreeMap，HashSet的底层是HahsMap。TreeSet和HashSet的区别就是TreeMap和HashMap的区别。

1. TreeMap是通过红黑树实现的，HashMap是通过哈希数组+链表+红黑树实现的。

2. TreeMap的数据是有序的，HashMap的数据是无序的。

3. TreeMap不可以存放null值，HashMap可以存放null值。

4. TreeMap比较元素是通过comparable和Comparator来实现的，HashMap是通过Hashcode和equals方法来实现的。



### final和static

**final**

1. final修饰类，表示这个类不能被继承。
2. final修饰方法，表示这个方法不能被子类重写。
3. final修饰变量，表示这个变量的引用不能被改变，但这个引用如果是一个对象，对象的内容可以被改变。

**static**

1. static修饰变量，该变量会生成在内存堆上，该变量与对象无关，被类控制，所有对该变量的引用都指向同一内存地址。
2. static修饰代码块，在类初次被加载的时候，会按照static块的顺序，执行每个static块。
3. static修饰方法的时候，可以使用类名.方法名直接调用方法，不需要实例化对象，但仅可以访问类的静态变量。
4. static可以修饰内部类对象，这样内部类对象可以作为一个普通类来使用，不需要实例化外部类对象。

```java
 1 public class OuterClass {
 2     public static class InnerClass{
 3         InnerClass(){
 4             System.out.println("============= 我是一个内部类'InnerClass' =============");
 5         }
 6     }
 7 }
 8 
 9 
10 public class TestStaticClass {
11     public static void main(String[] args) {
12         // 不需要new一个InnerClass
13         new OuterClass.InnerClass();
14     }
15 }
```

### equal、==、和hashcode

​		==在比较基本数据类型的时候比较的是值是否相等，在比较引用类型的变量的时候比较的是内存的地址。equal方法在没有重写的情况下比较的是地址是否相同，如果进行了重写，比较的一般是两个对象的内容是否相同。equals方法和hashcode方法都是继承自object类，重写了equal方法后，最好也要重写hashcode方法，否则在使用hashmap等集合的时候，逻辑上相等的两个对象可能出现存储两次的情况。equal相等hashcode相等，hashcode不等equals不等，hashcode相等推不出equal相等。



### 基本数据类型

![截屏2020-06-03 下午3.48.36](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-03 下午3.48.36.png)



### Int和Integer区别

答：Integer是Int的包装类，Int是java的一种基本数据类型。int和integer在进行比较的时候，integer会自动进行拆箱，两个int值进行比较。两个integer进行比较，关键在于是否创建了对象。满足两种条件会创建对象：1.使用`new integer()`2.值的范围超过`[-128,127]`。如果没有创建对象会缓存在IntegerCache中，此时进行比较就会相等。

```java
				Integer i1 = 128;
        int i2 = 128;
        System.out.println(i1 == i2); //True

        Integer i3 = 127;
        Integer i4 = 127;
        System.out.println(i3 == i4); //True

        Integer i5 = 128;
        Integer i6 = 128;
        System.out.println(i5 == i6); //False

        Integer i7 = 127;
        Integer i8 = new Integer(127); //False
        System.out.println(i7 == i8);
```

[参考资料]: https://blog.csdn.net/wangyang1354/article/details/52623703



### fail-fast和fail-safe区别

​		当使用迭代器遍历集合元素的时候，如果使用了除迭代器本身方法以外的其他方法改变集合的结构，则会抛出ConcurrentModificationException异常。这是因为迭代器在执行next()等方法的时候会执行checkForComodification()检查，查看modCount是否等于expectedModCount。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。这就是fail-fast

```java
final void checkForComodification() {
		if (modCount != expectedModCount)
    		throw new ConcurrentModificationException();
}
```

​	而fail-safe不会抛出异常，原因在于当集合结构被改变的时候，fail-safe机制会在原集合的基础上复制一份数据出来，然后在复制出来的数据上面继续遍历。

[参考资料]: :https://www.cnblogs.com/kubidemanong/articles/9113820.html



### String、StringBuilder和StringBuffer

答：这三个类的主要区别在运行速度和线程安全性

速度比较：StringBuilder > StringBuffer > String:因为String是final类且为字符串常量，因此一旦创建就不能被更改，所以String的操作实际上是不断创建然后回收对象的过程，因此在运行速度上很慢。而StringBuilder和StringBuffer的区别主要在与线程的安全性，StringBuffer中的大部分方法是有sychronized关键字进行修饰的，因此是线程安全的。但相较于StringBuilder来说性能上会受到一些影响。



### 类加载的方式

​		类的加载分为动态加载和静态加载。动态加载和静态加载的区别在于加载时机不同，静态加载的类在编译时期加载，因此在编译时期类必须存在，而动态加载的类在编译时期可以不存在。

**静态加载**：

​		使用new关键字加载类的实例对象。

**动态加载**：

1. 使用class.forName()来加载类。

2. 使用类加载器的loadClass()来加载类。

   区别在于class.forName()加载类是将类加载到虚拟机中并进行了初始化，而loadClass()方法没有对类进行初始化，只是把类加载到虚拟机中。

   

### 内存泄露

​		在Java中内存泄漏就是存在一些被分配的对象，这些对象有两个特点：1.首先这些对象是可达的，其次这些对象是无用的，即程序以后不会再使用这些对象。如果满足这两个条件这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC回收，然而它却占用内存。如：

1. 静态集合类，如hashmap，linkedlist等，如果这些集合是静态的，那么他们的生命周期与程序一致，容器中的对象在程序结束之前不能被释放。简而言之就是长生命周期的对象持有短生命周期对象的引用。
2. 没有关闭打开的资源。



### Integer和Long的hashcode方法有什么不同

​		Integer的hashcode方法直接返回value的值，Long的先右移32位再和原值异或，最后也返回一个int值。



### transient关键字

​		使用transient关键字修饰的属性不能再被序列化。



### countDownLatch、cyclicBarrier和Semaphore

​		countDownLatch实现了类似计数器的功能，一般用于一个任务等待其他几个任务执行完成以后才能执行的情况。cyclicBarrier可以让一组线程执行至某个状态后再一起执行，并且可以被重用。semaphore是信号量的意思，一般用于控制同时访问资源的个数，通过acquire获取许可，没有则等待，通过release释放许可。



### 序列化破坏单例模式

​		序列化和反序列化后得到的对象和单例模式中的对象不是同一个，破坏了单例模式，方法是在单例类里面定义一个readResolve方法返回单例对象。



### 程序设计五大原则

1. 单一职责原则：一个类应该只有一个引起它变化的原因。
2. 开放封闭原则：类模块是可拓展的，但是不可修改。
3. 里氏替换原则：子类必须能够替换它们的基类。
4. 依赖倒置原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于实现细节，实现细节应该依赖于抽象。
5. 接口隔离原则：模块间要通过抽象接口隔离，而不是通过具体的类耦合。



### 重写和重载的区别

​		重写是指子类对父类的实现方法重新编写，返回值和参数都不能改变。重载是指方法名称相同，而参数不同，返回值类型可以相同也可以不同。



### 接口和抽象类区别

1. 抽象类是用来对特征进行抽象，接口主要对功能进行抽象。

2. 抽象类要被子类继承，接口要被子类实现。

3. 接口只能做方法声明，抽象类可以用作方法声明，同时也可以用default关键字指定默认方法实现。

4. 抽象类可以有具体的方法和属性，接口中只能有抽象方法和不可变常量。

   

## 操作系统

### 进程与线程

**进程与线程的区别**

1. 进程是资源分配的最小单位，线程是资源调度的最小单位。

2. 进程有自己独立的地址空间，每启动一个进程，系统都将为它分配地址空间。而线程是共享进程中的数据的，使用相同的地址空间。因此线程切换一个进程和创建一个进程的花费远高于线程。

**进程间通信方式**

1. 管道：管道分为无名管道和命名管道，无名管道存储在内存中，仅供具有亲缘关系的进程之间通信。命名管道位于文件系统，没有亲缘关系的进程也可以使用命名管道进行通信。

2. 消息队列：在内核中创建一个队列，队列中的每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。

3. 信号量：

4. 共享内存：将同一块物理内存映射到不同进程的虚拟地址空间之中，实现不同进程对同一内存的访问。

5. socket：用于不同机器之间的通信。

**线程间同步方式**

互斥量、读写锁、条件变量。



### 用户态与内核态

​		用户态和内核态是操作系统的两种运行级别，当程序运行在R3特权级别的时候可以称为运行在用户态，在R0级别的时候可以成为运行在内核态。在用户态的级别只能访问受限的内存，且不允许访问外围IO设备等，只能使用非特权指令。而在内核态级别下可以访问内存中所有数据，包括外围IO设备。

​		应用程序大部分都是运行在用户态的状态之下，如果需要操作系统帮助完成某些在用户态完成不了的操作，便可以切换到内核态。用户态切换到内核态主要包括三种方式：

1.系统调用：操作系统在内核里都有一些内建的函数，这些函数可以完成一些系统级别的功能。比如fork指令调用的是sys_fork 

2.异常：当cpu在执行用户态的程序的时候发生了一些事先不可知的异常，则会切换到处理此异常的内核相关程序中，比如缺页异常。

3.外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，此时CPU会停止执行下一条指令而去处理中断，那么这个转换的过程就发生了由用户态向内核态的切换。



### fork

​		fork是linux中用来创建与父进程相同的子进程的系统调用函数，它创建了一个原有进程的精确副本，包括所有文件描述符、寄存器等全部内容。



### IO模型

​		操作系统有5种IO模型，分别是：

1. blocking IO：阻塞IO（BIO）

2. Non-blocking IO:非阻塞IO （NIO）

3. IO multiplexing:IO多路复用

4. signal driven IO：

5. asychronous IO:异步IO（AIO）

**区别**：

​		对于一个IO，会涉及到两个系统对象，调用这个IO的process和系统内核kernel。经历两个阶段：

1. 等待内核加载好所需数据。

2. 将数据从内核拷贝至进程之中。

   不同IO模型的区别就在于这两个阶段是否会阻塞。

BIO：当用户进程调用recvfrom系统调用，kernel开始准备数据，并且将数据从内核拷贝至用户空间，这个两个过程都是阻塞的。

NIO：当调用recvfrom时，如果kernel还没有准备好数据的时候会立即返回error，不会在第一阶段进行阻塞。

AIO：当进程执行read操作后，就可以开始做其他的事情了，不会产生任何阻塞，当内核准备好数据，且数据拷贝至用户空间之后才会通知，完全没有被阻塞。

[参考资料]:https://blog.csdn.net/historyasamirror/article/details/5778378



### select poll 和epoll

​		Linux通过socket睡眠队列来管理所有等待socket的某个事件的process，同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的process，通知process相关事件发生。

select：当用户线程调用select的时候，select会将所监控的文件描述符拷贝至内核空间，然后遍历，查看是否有可读事件，如果没有则接续睡眠，如果有则唤醒。这样有两个问题第一每次拷贝会造成性能损失，因此设置大小为1024。第二每次只要有一个数据可读都要遍历集合，效率低。

poll：poll解决了select大小限制的问题，使用了pollfd结构而不是select的fd_set结构。

epoll：首先应用内存映射的方式减少了每次都要把fd拷贝到内核空间的开销，其次使用红黑树的方式，组织fd集合，减少增删改的开销。并且引入一个双向链表作为单独的睡眠队列（因为一个进程要处理很多socket，因此此时睡眠的不是进程，而是对应的socket），解决了无效遍历的问题。并且epoll有两种触发模式，水平触发模式和边沿触发模式，区别在于水平触发模式是有数据可读一直触发，缓冲区不满一直触发。边沿触发模式是指当缓冲区状态发生改变的时候触发一次。

[参考资料]: https://cloud.tencent.com/developer/article/1005481



### 进程调度算法

1. 先来先服务。
2. 时间片轮转法。
3. 短作业优先调度。
4. 最短剩余时间优先：最短剩余时间是针对最短进程优先增加了抢占机制的版本)
5. 多级反馈队列:设置多个就绪队列，每个队列赋予不同的优先级，第一个队列最高，其余队列优先级逐次降低，在越高优先级的队列中时间片越小，当有一个新进程的时候首先放在最高优先级队尾，按照FCFS调度，如果能在一个时间片之内完成，则移除，否则进入下一优先级队列。



### 实模式

​		实模式体现在程序中用到的地址都是真实的物理地址。使用段基址和段内偏移地址的方式产生物理地址。这些都是真实的物理地址。



### 死锁的条件

1. 互斥条件：一个资源要么就是已经分配给了一个进程，要么就是可用的。
2. 占有和等待条件：已经获得了某个资源的线程可以再请求其他资源。
3. 不可抢占条件：已经分配给一个进程的资源不能被强制性的抢占。
4. 环路等待条件：死锁发生时，系统中一定有两个或者两个以上的进程组成一条环路。



## Linux

### 1. chmod

​		chmod命令是用来更改文件权限的，分为三种权限：

1. 写：w，权限值4

2. 读：r，权限值2

3. 执行：x，权限值1

其中按顺序分别表示，user、group和other的权限。例如：chmod741 表示user具有读写执行的权限，group具有写权限，other具有执行权限。



### 2.Linux 查看CPU和内存情况

​		top命令是Linux下常用的性能分析工具，能够显示系统中各个进程的资源占用情况。显示内容包括：用户占CPU百分比，内核占CPU百分比，空闲CPU，物理内存总量，使用内存总量等。

![img](https://img2018.cnblogs.com/blog/720994/201809/720994-20180918152552123-1390484337.png)



## Hadoop

### 1.hdfs小文件过多造成什么问题

答：首先小文件过多会在内存以对象的形式存储，这样会严重影响namenode的内存容量，制约集群的扩展性。其次访问大量小文件的速度远小于访问几个大文件，访问多个小文件就需要从不同的datanode中进行读取，严重影响速度。最后在处理小文件的时候大量时间花费在task的启停上，真正处理时间较小，影响效率。



### 2.Mapreduce join操作

答：

1.reduce side join：map阶段读取两个表，在reduce阶段进行shuffle，将具有同一个key的数据拉取到同一个reducer进行join操作。

2.map side join：这种情况适用于两个表中有一个表非常小的情况，可以将小表直接放入内存中使得每个map task内存中保存一份，避免shuffle的开销。

3.半连接：选取小表，将其参与join的key抽取出来，然后将这些key发送到map task的内存中，将不存在的key进行过滤，减少shuffle的数据量。



### 3. hive sql转化为mapreduce的过程

1. Antlr定义sql语法规则，完成SQL词法、语法解析，将sql转化为抽象语法树AST Tree。

 	2. 遍历AST Tree，抽象出查询基本组成单元QueryBlock。
 	3. 遍历QueryBlock，翻译为执行操作树Operator Tree。
 	4. 逻辑层优化器进行Operator Tree变换，合并不必要的operator。
 	5. 遍历operatorTree，翻译为MapReduce任务。
 	6. 物理层优化器进行MapReduce任务的变换，最终生成执行任务。

[参考资料]: https://blog.csdn.net/youzhouliu/article/details/70807993





## Spark

### 1. groupByKey 和 reduceByKey的区别

​		reduceByKey用于对每个key的多个value进行聚合操作，并且它能够在本地先进行merge操作，且merge操作可以自定义。GroupByKey也是对每个key进行操作但只生成一个sequence，因此groupByKey不支持自定义函数的聚合操作。如果要对sequence进行聚合操作需要先用groupByKey生成RDD然后再在rdd上使用map操作进行聚合。总体来说如果要对同一个key的value进行聚合操作使用reduceByKey，节省网络传输开销，效率高。

[参考资料]: https://blog.csdn.net/weixin_41804049/article/details/80373741

### 2.spark分区

​		spark有三种分区方式，分别是HashPartitioner、RangePartitioner和CustomPartitioner。默认是使用HashPartitioner进行分区，partition = key.hashCode() % numPartitions。RangePartitioner会对key值进行排序，然后将key值划分成numPartitions份。



## 数据结构

### 跳表

​		跳表全称是跳跃链表，是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。一开始在最稀疏的层进行搜索，知道需要查找的元素在该层两个相信元素的中间，这时跳表转到下一层，继续刚才的搜索，知道找到相应元素为止。查找和插入的时间复杂度都是O(logN)，是一种拿空间换时间的数据结构。



### 布隆过滤器

​		布隆过滤器是一个很长的二进制向量和一系列随机映射函数。特点是高效的查询和插入，它可以用来告诉你某样东西一定不存在或者可能存在。如果我们要映射一个值到布隆过滤器中，就要使用多个映射函数生成多个哈希值，然后对每个哈希值指向的bit位置1。查询的时候逆向查询。



### 完全二叉树和满二叉树

​		满二叉树是完全二叉树的一种特殊情况，满二叉树是一个三角形，最后一层都是叶子结点，其他各层都是非叶子结点。完全二叉树最后一层节点可以不满，但是是从左向右填充的。



##  大数据

### 1. 数仓分层

​		数仓分层的优点：

1. 把复杂问题简单化，把复杂问题分为多个步骤来完成，每层只处理单一问题，比较简单和容易理解。
2. 数据结构清晰：每一个数据分层都有作用域，便于维护数据的准确性，当数据出现问题的时候，可以不用修复所有的数据，只需要从有问题的步骤开始修复。
3. 提高数据的复用性：规范数据分层，通过中间层的数据能够极大的减少运算，增加计算结果的复用性。
4. 对数据层之间进行解耦：保护层与层之间的数据，解耦合。

![截屏2020-09-03 下午2.05.31](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-09-03 下午2.05.31.png)





1. 日志方面的采集。
2. 数据导出。
3. 

