# 面试 

## JVM

### 1.运行时的数据区域

答：JVM运行时数据区域大致分为5部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区。java8之后本地方法区变成了metaspace，放入了堆中。

​		程序计数器主要记录执行的字节码行号等信息，方便指令跳转。虚拟机栈是线程私有的，执行方法时创建栈帧存储局部变量，操作数，方法出口等信息。本地方法栈和虚拟机栈差不多，不过是为本地方法服务的。堆主要保存对象的实例。方法区主要保存类的信息，常量等。

### 2.垃圾回收机制

答：垃圾回收主要是在堆上，对于对象的实例分为新生代和老年代。同时新生代又分为1个Eden区域和2个Survivor区域，单个Eden：Survivor=8:1。新创建的对象主要生成在Eden区域，然后minor gc采用复制算法，达到一定次数以后进入老年区。

### 3.垃圾回收算法

答：主要垃圾回收算法包括：1.引用计数法；2.可达性分析法；3.标记-清理法；4.标记-整理法；5.复制法；6.分代收集法。

### 4.Minor GC和Full GC触发条件

答：Minor GC作用于新生代，当无法为新对象分配空间时发生Minor GC。Full GC是老年代，1.调用system.gc()；2.空间分配担保失败时候发生Full GC；3.新进大对象进入老年代超过内存大小发生

### 5.GC ROOT的起点都可以包括什么

答：1.虚拟机栈中直接引用的对象；2.方法区中类静态变量和常量引用的对象；3.本地方法栈中JNI（即一般说的native方法）引用的对象

### 6.GC中的STW(stop the world)

答：stop the world 是指JVM运行过程中，除了垃圾收集线程，其他线程都被挂起的情况。Serial收集器，CMS收集器都会发生这种情况。

### 7.各个垃圾回收器的特点和区别

答：Serial/Serial Old收集器是单线程收集器，特点是简单快速，但是gc时会发生STW；ParNew收集器是Serial收集器的多线程版本，指垃圾收集是多线程的，也会发生STW，主要用于配合CMS收集器用作新生代收集器。Parallel/Parallel OLD 可控吞吐量。CMS最短时间为目标的老年代收集器分为4步初始标记、并发标记、重新标记、并发清除。除了初始标记和重新标记STW剩下多线程执行。缺点是CPU敏感、无法处理浮动垃圾、会产生碎片(标记清除)。G1收集器具有并发，分代，整合，可预测的特点，监控每个region，在有限时间收集价值最高的垃圾。

### 8.什么是Java内存模型

答：Java内存模型定义了JVM操作虚拟机时的工作方式，是对内存进行读写访问的过程抽象。

### 9.Java内存模型存在什么问题

答：Java每个线程都有单独的工作内存，他们不能够直接操作主存，因此会有线程之间的可见性问题，并且因为编译器会进行代码优化，所以也会有指令重排的问题。

### 10.volatile关键字是怎么实现的

答：volatile关键字是通过内存屏障来实现变量的可见性和防止指令重排。每次读volatile变量的时候都会使本地的工作内存无效化，直接从主存拷贝副本。每次写volatile变量都会立刻刷新到主存之中。

### 11.怎么理解内存屏障

答：内存屏障可以看作多线程之间的同步点，内存屏障之前的操作必须都进行完毕，并将变量值刷入主存后才能执行之后的内容，并且内存屏障内的代码不允许指令重排。

### 12.说几个先行发生原则

答：1.程序次序原则；2.管程锁定原则；3.volatile变量原则；4.线程启动原则

### 13.类加载过程

答：过程如下：

1.加载：主要是指通过类的全限定名称来获取定义此类的二进制字节流。

2.验证：验证的目的是为了确保字节流中包含的信息符合当前虚拟机的要求。

3.准备：正式为类变量分配内存，并设置类变量初始值的阶段。

4.解析：解析是虚拟机将常量池内的符号引用转换为直接引用的过程。

5.初始化：开始正式执行类中定义的Java程序代码。

6.使用：

7.卸载：

### 14.双亲委派模型和优点

答：类加载器分为3类，分别是启动类加载器，扩展类加载器和应用程序类加载器。双亲委派模型要求除了启动类加载器外，剩下的类加载器都应当有自己的父类加载器。如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是委派给父类加载器去完成，只有父类无法完成时，子类加载器才会尝试自己去加载。

**优点**

1.防止同一个类被重复加载，保证安全性。

2.保证核心的类不能被更改。

**如何打破**

答：如果不想打破双亲委派模型，就重写ClassLoader类中的findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写loadClass()方法。



## SQL

### 1.SQL执行流程

![截屏2020-04-23下午4.39.11](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-23下午4.39.11-7631167.png)

答：1.客户端通过TCP连接发送连接请求到MySql连接器，连接器会对该请求进行权限验证以及连接资源分配。2.客户端发送一条语句，如果是select语句，在开启查询缓存的情况下，首先在查询缓存中查找该SQL是否完全匹配。3.如果在查询缓存中没有匹配成功，则将语句交给分析器做词法分析和语法分析。4.分析器分析的之后进入优化器，比如多个索引如何选择索引等。5.执行器调用引擎的接口，并返回调用的结果。

### 2.SQL的分类

答：SQL语句主要可以划分为以下三个类别：

1.DDL(Data Definition Languages)语句：数据定义语言。

2.DML(Data Manipulation Language)语句：数据操纵语句。

3.DCL(Data Control Language)语句：数据控制语句。

### 3.事务的基本要素

答：ACID。A：原子性，所有操作都是原子操作。C：一致性，事物必须保持系统处于一致的状态。I：隔离性，保证事物之间是相互隔离的。D：事务完成之后，便被持久化到磁盘之中，不会被更改。

### 4.事物的隔离级别

答：Read Uncommitted，Read Committed，Repeated Read, Serializable

### 5.InnoDB和MyISAM的区别

答：MyISAM和InnoDB都是MySQL的存储引擎。区别主要在MyISAM不是事务安全的，没有外键，且MyISAM只支持表锁。InnoDB支持事物和行锁。同时MyISAM和InnoDB的索引也有所不同，MyISAM使用的是非聚集索引，InnoDB使用的聚集索引。

### 6.MVCC

答：MVCC的目的是并发访问数据库时，对正在事务内处理的数据做多版本的管理。以达到用来避免写操作的拥塞。利用当前读和快照读的方式来解决幻读等问题。

### 7.Join语句中on和where条件的区别

答：on是在表连接的时候起作用，where是生成连接表之后再对连接表进行过滤。

### 8. 数据库三大范式

答：第一范式：确保每列保持原子性，数据库表中的每列都是不可分解的原子值。第二范式：保证每列都和主键相关。第三范式：确保每列都和主键直接相关，而不能间接相关。

### 9. 什么是索引回表

答：非主键索引需要通过B+树获取id值后，进行回表，通过主键索引查找到对应数据。避免的话可以通过覆盖索引，就是第一次查找的时候就返回了所需要的数据。



## 多线程

### 1.线程的几种状态

答：线程有6种状态，分别是:New:刚刚创建的线程、Runnable:准备就绪、Waiting:无时间限制等待、Blocked:被阻塞，比如synchronized同步块、Timed_waiting限时等待和Terminated:结束。

### 2.线程创建的方式

答：线程创建有三种方式：

1.继承Thread类，重写run方法，使用start()方法来启动线程。

2.实现Runnable接口，重写run方法，使用start()方法来启动线程。

3.通过Callable和Future创建线程，实现Callable接口，实现call()方法

### 3.线程池的种类

答：为了避免频繁的创建和销毁线程，让线程复用可以创建线程池。线程池主要有以下几种：

1.newFixedThreadPool:返回一个固定数量的线程池。

2.newSingleThreadExecutor:返回一个只有一个线程的线程池。

3.newCachedThreadPool:返回一个可以根据实际情况调整线程数量的线程池。

4.newSingleThreadScheduledExecutor和newScheduledThreadPool:扩展了在给定时间执行任务的功能。

### 4.线程池的内部实现

答：上面的线程池都是ThreadPoolExecutor的封装类。

![截屏2020-04-24下午3.32.43](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-24下午3.32.43.png)

任务队列：

1.直接提交队列：每来一个任务都直接提交，超过了最大线程数量，执行拒绝策略。

2.有界任务队列：ArrayBlockingQueue来实现的，有最大容量限制。

3.无界任务队列：LinkedBlockingQueue来实现的，无最大容量限制。

4.优先级队列：PriorityBlockingQueue来实现，根据任务优先级来执行。

拒绝策略：

1.AbortPolicy策略：该策略直接抛出异常，阻止系统正常运行。

2.CallerRunsPolicy：只要线程池未关闭，直接在调用者线程中，运行当前任务。提交线程性能下降。

3.DiscardOldest:抛弃最老的请求。

4.DiscardPolicy：抛弃无法处理的这个请求。

### 5.线程池个数

答：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目。

如果是CPU密集型应用，则线程池大小设置为N+1。因为cpu密集型应用频繁切换上下文，会带来额外的开销。

如果是IO密集型应用，则线程池大小设置为2N+1。IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间

### 6.wait和sleep的区别

答：sleep属于Thread类，表示让一个线程进入睡眠状态，等待一段时间以后自动唤醒，没有释放锁。wait属于object，释放了锁，如果设置了超时时间并不需要其他线程使用notify方法也能解除阻塞。否则需要调用notify方法。

### 7.并行和并发的区别

答：并发是指一个处理器同一时刻只能执行一条指令，但是多个任务快速切换，给人们一种同时执行的感觉，是逻辑上的同时发生。并行是指多个处理器同时执行多条指令，是物理上的同时发生。

### 8. notify和notifyall的区别

答：JVM会为使用锁的对象维护两个集合，锁池和等待池。

**锁池**：对于锁池来说，如果线程A持有了对象锁，此时有其他线程BC获取锁，则BC进入锁池，BC的线程状态为blocked。

**等待池**：如果线程A调用了wait，则线程A进入了等待池，并且线程处于waiting状态。

如果对象想要获得锁，有两个先决条件：1.持有锁的对象释放了锁。2.线程处于runnable状态。处于锁池的对象在锁被释放以后自动唤醒某一线程。处于等待池的对象必须要通过notify或者notifyall来唤醒，notify只能唤醒一个线程从锁池进入等待池，而notifyall可以换行所有对象进入锁池。复杂情况下notify可能产生死锁。

[参考资料]:(https://www.jianshu.com/p/25e243850bd2?appinstall=0)

### 9. 线程池执行流程

​		![截屏2020-08-11 下午5.57.47](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-08-11 下午5.57.47.png)

​		任务被提交到线程池，执行execute方法先判断线程数量是否小于corePoolSize，如果小于则调用addWorker方法，否则放入等待队列，如果等待队列满了则判断当前线程数量是否小于maximumPoolSize，如果小于则创建线程执行任务，否则执行拒绝策略。Worker类是实现线程复用的关键类，Worker实现了Runnable接口，同时将我们提交的任务封装成task对象。当调用start方法时候实际上是新建线程执行了Worker类的run方法，直接调用task的run方法。因此实际上是做到了Worker的复用。

[参考资料]:(https://blog.csdn.net/weixin_38106322/article/details/105429550)

### 10.线程池中的shutdown()和shutdownNow()的区别

​		shutdown和shutdownNow两个方法都可以关闭线程池。区别在于shutdown是将线程池的状态设置为SHUTDOWN状态，正在执行的和在等待队列中没有执行的任务不受影响，但无法添加新的任务。shutdownNow则是将线程池的状态设置为STOP，正在执行的任务被停止，没有执行的任务返回。

### 11. start方法和run方法

​		调用start方法可以启动线程，而run方法只是thread类里面一个普通方法，还是在主线程里面执行。

### 12. ThreadLocal

ThreadLocal是一个线程内部的存储类，提供了线程内存储变量的能力，并且每一个线程读取的变量是相互独立的，能够做到线程安全。ThreadLocalMap是ThreadLocal的静态内部类，所有的方法都是private的，因此只有ThreadLocal能够进行操作。每个Thread都有一个TheadLocal.ThreadLocalMap对象，ThreadLocalMap的key就是ThreadLocal类型，value是Object类型。因此能够做到线程安全。

## 计算机网络

### 1.Http & Https



### 2.键入URL对应过程

答：过程如下：

1.输入URL，URL是指统一资源定位符

2.浏览器查找域名的IP地址（DNS协议）：请求一旦发起浏览器首先要做的就是解析这个域名，找到对应的ip地址。按照本地硬盘的hosts文件 -> 本地DNS服务器 -> 根DNS服务器 -> 域DNS服务器的顺序进行请求。

3.浏览器向web服务器发送http请求：浏览器拿到域名对应的ip地址以后向服务器发起TCP连接请求

4.服务器处理请求：后段会通过TCP连接进行处理，对HTTP协议进行解析，并按照格式封装成HTTP对象供上层使用。如果网站流量较大，会将同一个应用部署在多台服务器上，此时客户端不是通过HTTP协议直接访问网站服务器，而是通过nginx等反向代理服务器，nginx收到请求，再根据规则请求真正的应用服务器，最后将结果返回客户端。

5.浏览器接收服务器返回结果并显示页面：浏览器接收HTTP响应，响应包括：状态行，响应头，响应正文。浏览器显示页面，完成一次对应过程。

[参考资料]:(https://blog.csdn.net/wlk2064819994/article/details/79756669)

### 3.常用状态码

答：200:OK、404:NOT FOUND，资源不存在、400:BAD REQUEST，参数无效、403:FORBIDDEN客户端错误

### 4.TCP三次握手和四次挥手

答：ACK：确认值，ack：确认编号， SYN：发起链接，FIN：释放链接, SEQ:顺序号码

**三次握手**

![截屏2020-06-02 下午3.29.06](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-02 下午3.29.06.png)

1.客户端向服务器端发送TCP报文，标记位为SYN，表示请求链接。

2.服务器端返回一段报文，标志位为SYN和ACK，表示收到报文，并确认创建链接。

3.客户端发送确认报文，标志位为ACK。完成SYN-SENT阶段，开始正常数据传输。

**为什么要进行第三次握手**

答：首先服务器端的资源比较宝贵，第三次握手是为了防止服务器端的资源被浪费。比如第二阶段的报文丢失，超过了超时时间，客户端又重新发送新建链接的报文，此时第一次的服务器端口就一直开着被占用，造成严重的浪费。又比如已经超时的第一阶段报文到达服务器，而此时服务器以为是有效请求，同样开启端口。因此为了减少服务器端的开销，需要三次握手。

**四次挥手**

![截屏2020-06-02 下午3.50.05](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-02 下午3.50.05.png)

1.客户端想要释放链接，发送报文，标记位为FIN，进入FIN-WAIT阶段。

2.服务器端收到报文后回复ACK报文，进入CLOSE-WAIT阶段。

3.当服务器端准备好释放链接后，发送报文，标记位为FIN和ACK，表示准备好释放链接，进入LAST-ACK阶段。

4.客户端回复ACK报文，标记位为ACK，进入TIME-WAIT 2MSL阶段。服务器端收到最后的报文后关闭链接。

**为什么握手是三次，挥手却要四次**

答：TCP连接建立的时候之所以只要三次握手是因为在第二次的过程中，服务器端发送给客户端的报文同时包括了ACK和SYN标志位，是再一次握手中传输的。断开连接的时候之所以需要四次挥手，是因为FIN和ACK是分两次进行传输的，因为服务器在收到释放链接请求的时候不能立即释放，还有数据需要处理，因此服务器端首先回复ACK报文，再在准备好之后回复FIN释放链接，因此需要四次挥手。

**为什么客户端在TIME-WAIT要等2MSL**

答：为的是确认服务器端收到客户端第四阶段的ACK报文。MSL指的是一段TCP报文最大的生命周期。如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。

[](https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc)

### 5. TCP如何确保可靠传输

答：

**数据的合理分片和排序**

1.校验和：TCP保持一个端到端的校验和，目的是检测数据在端到端的传输中是否有变化。

2.确认和重传：每次接收方接收到数据后，都会对传输方进行确认应答。因此如果长时间没有收到响应报文，就会启动重传机制。

3.流量控制：TCP连接的每一方，都会有固定大小的buffer，当接收方的缓冲区大小不够来不及及时处理发送方的数据，能提示发送方降低发送速率，防止包丢失，对应TCP来说是使用的可变大小的滑动窗口。

4.拥塞控制：当网络发生阻塞的时候，减缓发送速率。慢开始（指数增长），拥塞避免（线性增长），快重传（收到三个重复确认直接重传），快恢复（恢复后不是从1开始）

![截屏2020-08-09 下午3.12.52](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-08-09 下午3.12.52.png)

### 6.粘包现象

答：首先TCP是一个基于字节流的传输控制协议，因此并不存在包的概念。广义上的TCP粘包现象是指发送方发送的数据到达接收方缓冲区后没有被正确及时的处理，导致不同应用没有处理好字节流之间的分割，导致“粘包”现象的发生。

### 7.网络的五层模型和七层模型

答：OSI的7层模型分别是：应用层(HTTP)，表示层，会话层，传输层(TCP,UDP)，网络层，数据链路层和物理层。五层模型包括：应用层，传输层，网络层，数据链路层和物理层。



### 8. Cookie、Session、Token

**Cookie和Session**

​		Cookie和Session是用来实现会话跟踪技术的。Cookie实际上是一小段文本信息（4k），如果服务器需要记录该用户状态，就向浏览器发送一个Cookie，客户端进行保存。Session是保存在服务器上，每个用户分配一个session_id，每次使用session_id进行查询。

区别在于：

1.Cookie存储在客户的浏览器上，Session存储在服务器上。

2.安全性：Cookie不是很安全。

3.服务器性能：Session会在一定时间保存在服务器上。当访问增多会占用服务器的性能。

4.数据：cookie大小不能超过4k，session没有数据量的限制，可以保存更加复杂的类型。

5.生存周期：session的生存周期较短，浏览器关闭或者定时结束。cookie可以永久保存。



**Session和Token**

​		Token是无状态的令牌。与cookie和session不同的是，token并不是用来进行会话跟踪的实现，而是用来对用户进行验证，只对用户的权限进行验证，并不会在服务器端保存用户的信息。token一般由uid(用户唯一标志) + time(时间戳) + sign(签名)组成，每次登陆对token进行校验，来验证用户权限。

### 9. ARP协议

答：ARP协议是Address Resolution Protocol地址解析协议的缩写。其作用是在以太网的环境中，数据传输所依赖的是mac地址而不是IP地址，而将IP地址转换为mac地址的工作是由ARP协议来完成的。

**工作原理**：

在任何时候，当主机需要找出网络中的另一个主机的物理地址的时候，他就可以发送一个ARP请求报文，这个报文包装了发送方的MAC地址，发送方的IP地址，以及接收方的IP地址。这个报文会在网络层中进行广播。每一台主机都会接收并处理这个ARP请求报文，然后进行验证，查看接收方IP地址是不是自己的，只有验证成功的主机才会返回一个ARP响应报文，这个响应报文包含接收方的IP地址和mac地址。因此发送方就可以得到目标的mac地址。



## JAVA

### 1.ArrayList和LinkedList区别

答：区别如下：

1.ArrayList是基于数组的数据结构，LinkedList是基于链表的数据结构。

2.对于随机访问的方法ArrayList优于LinkedList，因为数组支持随机访问，LinkedList要移动指针。

3.对于插入删除数据操作LinkedList要优于ArrayList，因为ArrayList要移动数据。

### 2.Exception的父类，几种错误

![截屏2020-04-24下午4.18.42](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-24下午4.18.42.png)

### 3.锁

答：锁的本质是依赖底层操作系统的Mutex Lock来实现的，因此用户态需要切换成内核态，浪费开销，因此JVM会对加锁进行优化，避免进入内核态，提高效率。按照竞争条件分为：无锁 < 偏向锁 < 轻量级锁 < 重量级锁。

在JVM中，对象在内存中的布局分为三块区域：对象头，对象体和填充区域。其中对象头中的mark word区域用来标记对象锁的状态。

1.对象创建初始，没有任何线程来竞争。这时偏向锁标识位是0，锁状态01，说明该对象处于无锁状态（无线程竞争它）。

![截屏2020-07-06 下午11.06.54](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-07-06 下午11.06.54.png)

2.当有一个线程竞争锁的时候进入锁偏向状态。这时Mark Word会记录自己偏向的线程的ID。

![截屏2020-07-06 下午11.08.40](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-07-06 下午11.08.40.png)

3.当有多个线程开始竞争同一把锁的时候，首先尝试轻量级锁（CAS），如果在短时间内持有锁的进程放弃锁，使用轻量级锁能够大大减少开销。

![截屏2020-07-06 下午11.13.19](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-07-06 下午11.13.19.png)

4.当使用轻量级锁无法完成加锁的时候，便会膨胀成重量级锁。

![截屏2020-07-06 下午11.14.44](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-07-06 下午11.14.44.png)

[参考资料]: https://blog.csdn.net/scdn_cp/article/details/86491792



### 4.Hash

答：Hash就是把任意长度读输入，通过散列算法，变成固定长度的输出，该输出就是散列值。

**Hash冲突的处理方式**

答：Hash冲突的处理方法有以下几种：

​		1.开放地址法(线性探查)：当冲突发生时候，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个序列一次查找下去，当碰到一个空单元的时候，插入其中。

​		2.拉链法：冲突发生的时候，使用链表存储散列值相同的元素。

​		3.建立公共溢出区域：把冲突放在另一个公共溢出区中。

​		4.再Hash方法：计算散列值方法不止一个，如果有冲突发生再次计算散列值。



### 5. HashMap

答：HashMap的底层实现是数组+链表结构，当链表长度达到一定长度的时候链表会转化为红黑树，HashMap不是线程安全的。

**1.HashMap的key和value可以为空值吗**

​		HashMap的key和value均可以为空值。（注：HashTable的key和value都不能为空）

**2.HashMap的扩容机制**

​		HashMap的初始默认负载因子(load_factor)为0.75，初始默认大小为16.当结点个数大于负载因子*容量大小的时候发生扩容。

**3.扩容为什么是2的倍数**

​		HashMap是使用(n-1)&hash的方法计算元素在数组中的位置，这里的n就是HashMap的数组长度，因此如果n是2的倍数，n-1就能保证除了最高位剩下的都是1，这样在与hash值计算的时候就能够充分散列，最大程度上避免散列冲突。

![截屏2020-04-25上午10.08.53](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午10.08.53.png)

**4.HashMap是如何实现Hash算法的**

​		首先算出hashCode右移16位做异或运算(相同为0不同为1)

![截屏2020-04-25上午9.25.12](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午9.25.12.png)

**5.红黑树转换**

​		当某一链表长度binCount >= TREEIFY_THRESHOLD - 1的时候进入treeifyBin方法。但是此时并不一定进行扩容，因为在treeifyBin方法中还要对数组长度进行判断，当数组长度小于MIN_TREEIFY_CAPACITY(默认64)的时候不会进行转换。

![截屏2020-04-25上午9.44.05](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午9.44.05.png)

**6.多线程操作HashMap会造成什么问题**

​		因为HashMap不是线程安全的因此当多线程操作HashMap扩容的时候会造成循环链表的的问题。

**7.如何避免多线程问题的产生**

​		如果知道元素个数，可以初始化长度，并且将负载因子设置为1，这样可以有效避免扩容的出现。

**8.为什么选择8作为转化红黑树的阈值**

​		因为hash算法服从泊松分布，当单一链表超过8的时概率小于百万分之一。



### 6.HashMap、HashTable、ConcurrentHashMap

答：HashTable是线程安全的，实现方式是在操作上加上sychronized关键字，因此会锁整张表，效率较低。HashMap是线程不安全的。ConcurrentHashMap是线程安全的。

### 7.ConcurrentHashMap 1.7和1.8的区别

答：

1.整体结构：1.7使用的是Segment+HashEntry，1.8移除了segment，使锁的粒度更小，使用类似HashMap的Node+CAS+synchronized的形式。

2.put操作：1.7先定位segment再定位桶，put的全程加锁。没有获取锁的线程最多自旋64次，超过则挂起等待唤醒。1.8直接定位桶，为空则CAS插入，否则加锁put

3.size操作：1.7计算两次size看看是否相等，这种操作最多重复三次。如果还是不想等则对每个segment加锁，再计算。1.8使用volatile类型的baseCount来记录元素的个数。



### 8. set是如何保证key不会重复的

答：最常用的HashSet的底层是使用HashMap来实现的，HashMap保证了key的唯一性。

### 9.final和static

**final**

答：final修饰类，表示这个类不能被继承。final修饰方法，表示这个方法不能被子类重写。final修饰变量，表示这个变量的引用不能被改变，但这个引用如果是一个对象，对象的内容可以被改变。

**static**

答：static修饰变量，该变量会生成在内存堆上，该变量与对象无关，被类控制，所有对该变量的引用都指向同一内存地址。static修饰代码块，在类初次被加载的时候，会按照static块的顺序，执行每个static块。static修饰方法的时候，可以使用类名.方法名直接调用方法，不需要实例化对象，但仅可以访问类的静态变量。static可以修饰内部类对象，这样内部类对象可以作为一个普通类来使用，不需要实例化外部类对象。

```java
 1 public class OuterClass {
 2     public static class InnerClass{
 3         InnerClass(){
 4             System.out.println("============= 我是一个内部类'InnerClass' =============");
 5         }
 6     }
 7 }
 8 
 9 
10 public class TestStaticClass {
11     public static void main(String[] args) {
12         // 不需要new一个InnerClass
13         new OuterClass.InnerClass();
14     }
15 }
```

### 10. equal、==、和hashcode

答：==在比较基本数据类型的时候比较的是值是否相等，在比较引用类型的变量的时候比较的是内存的地址。equal方法在没有重写的情况下比较的是地址是否相同，如果进行了重写，比较的一般是两个对象的内容是否相同。equals方法和hashcode方法都是继承自object类，重写了equal方法后，最好也要重写hashcode方法，否则在使用hashmap等集合的时候，逻辑上相等的两个对象可能出现存储两次的情况。equal相等hashcode相等，hashcode不等equals不等，hashcode相等推不出equal相等。

### 11. 基本数据类型

![截屏2020-06-03 下午3.48.36](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-06-03 下午3.48.36.png)

### 12. Int和Integer区别

答：Integer是Int的包装类，Int是java的一种基本数据类型。int和integer在进行比较的时候，integer会自动进行拆箱，两个int值进行比较。两个integer进行比较，关键在于是否创建了对象。满足两种条件会创建对象：1.使用`new integer()`2.值的范围超过`[-128,127]`。如果没有创建对象会缓存在IntegerCache中，此时进行比较就会相等。

```java
				Integer i1 = 128;
        int i2 = 128;
        System.out.println(i1 == i2); //True

        Integer i3 = 127;
        Integer i4 = 127;
        System.out.println(i3 == i4); //True

        Integer i5 = 128;
        Integer i6 = 128;
        System.out.println(i5 == i6); //False

        Integer i7 = 127;
        Integer i8 = new Integer(127); //False
        System.out.println(i7 == i8);
```

[]:https://blog.csdn.net/wangyang1354/article/details/52623703

### 13. fail-fast和fail-safe区别

答：当使用迭代器遍历集合元素的时候，如果使用了除迭代器本身方法以外的其他方法改变集合的结构，则会抛出ConcurrentModificationException异常。这是因为迭代器在执行next()等方法的时候会执行checkForComodification()检查。也就是说，如果在迭代器遍历元素的时候，如果modCount这个值发生了改变，那么再次遍历时就会抛出异常。这就是fail-fast

```java
final void checkForComodification() {
		if (modCount != expectedModCount)
    		throw new ConcurrentModificationException();
}
```

而fail-safe不会抛出异常，原因在于当集合结构被改变的时候，fail-safe机制会在原集合的基础上复制一份数据出来，然后在复制出来的数据上面继续遍历。

[]:https://www.cnblogs.com/kubidemanong/articles/9113820.html

### 14. String、StringBuilder和StringBuffer

答：这三个类的主要区别在运行速度和线程安全性

速度比较：StringBuilder > StringBuffer > String:因为String是final类且为字符串常量，因此一旦创建就不能被更改，所以String的操作实际上是不断创建然后回收对象的过程，因此在运行速度上很慢。而StringBuilder和StringBuffer的区别主要在与线程的安全性，StringBuffer中的大部分方法是有sychronized关键字进行修饰的，因此是线程安全的。但相较于StringBuilder来说性能上会受到一些影响。

### 15.类加载的方式

答：类的加载分为动态加载和静态加载。动态加载和静态加载的区别在于加载时机不同，静态加载的类在编译时期加载，因此在编译时期类必须存在，而动态加载的类在编译时期可以不存在。

**静态加载**：使用new关键字加载类的实例对象。

**动态加载**：1.使用class.forName()来加载类。2.使用类加载器的loadClass()来加载类。区别在于class.forName()加载类是将类加载到虚拟机中并进行了初始化，而loadClass()方法没有对类进行初始化，只是把类加载到虚拟机中。

### 16.sychronized和ReentrantLock区别

答：

- 实现的区别

sychronized是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock是jdk1.5之后提供的API层面的互斥锁。

- 功能的区别：

相比于sychronized，reentrantLock类提供了一些高级的功能，主要有以下三项：

1. 等待可中断：持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待。
2. 公平锁：sychronized锁是非公平的，ReentrantLock默认的构造函数可以通过参数true设置为公平锁。
3. 绑定多个条件：ReentrantLock对象可以同时绑定多个Condition条件，实现分组唤醒。

### 17.内存泄露

​		在Java中内存泄漏就是存在一些被分配的对象，这些对象有两个特点：1.首先这些对象是可达的，其次这些对象是无用的，即程序以后不会再使用这些对象。如果满足这两个条件这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC回收，然而它却占用内存。

### 18. TreeSet和HashSet是如何比较两个元素相等的

​		TreeSet的底层是TreeMap，HashSet的底层是HahsMap。TreeSet和HashSet的区别就是TreeMap和HashMap的区别。

1.TreeMap是通过红黑树实现的，HashMap是通过哈希数组+链表+红黑树实现的。

2.TreeMap的数据是有序的，HashMap的数据是无序的。

3.TreeMap不可以存放null值，HashMap可以存放null值。

4.TreeMap比较元素是通过comparable和Comparator来实现的，HashMap是通过Hashcode和equals方法来实现的。

### 19.Integer和Long的hashcode方法有什么不同

​		Integer的hashcode方法直接返回value的值，Long的先右移32位再和原值异或，最后也返回一个int值。

### 20.transient关键字

答：使用transient关键字修饰的属性不能再被序列化。

### 21.countDownLatch、cyclicBarrier和Semaphore

答：countDownLatch实现了类似计数器的功能，一般用于一个任务等待其他几个任务执行完成以后才能执行的情况。cyclicBarrier可以让一组线程执行至某个状态后再一起执行，并且可以被重用。semaphore是信号量的意思，一般用于控制同时访问资源的个数，通过acquire获取许可，没有则等待，通过release释放许可。

### 22. 序列化破坏单例模式

序列化和反序列化后得到的对象和单例模式中的对象不是同一个，破坏了单利模式，方法是在单例类里面定义一个readResolve方法返回单例对象。

### 23.sychronized关键字是怎么实现的

答：sychronized分为两种情况。

1.加在方法上，JVM可以从方法常量池中的ACC_SYCHRONIZED标识位区分一个方法是不是同步方法，如果是则线程使用操作系统的管程持有monitor，然后执行方法，在方法结束后退出monitor。

2.加在代码块上，是利用monitorenter和、monitorexit这两个字节码来实现的。分别位于代码的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。

注：

1.当线程A执行对象的synchronized代码块的时候，线程B依然可以访问方法中非synchronized块的部分。

2.当线程A执行对象的synchronized代码块的时候，线程B如果要访问该代码块则被阻塞。

[参考资料]：（https://www.cnblogs.com/aspirant/p/11470858.html）

## 操作系统

### 1. 进程与线程

**进程与线程的区别**

1.进程是资源分配的最小单位，线程是资源调度的最小单位。

2.进程有自己独立的地址空间，每启动一个进程，系统都将为它分配地址空间。而线程是共享进程中的数据的，使用相同的地址空间。因此线程切换一个进程和创建一个进程的花费远高于线程。

**进程间通信方式**

1.管道：在内核中申请一段固定大小的缓冲区，程序拥有写入和读取的权利。

2.消息队列：在内核中创建一个队列，队列中的每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。

3.信号量

4.共享内存：将同一块物理内存映射到不同进程的虚拟地址空间之中，实现不同进程对同一内存的访问。

5.socket：用于不同机器之间的通信。

**线程间通信方式**

互斥量、读写锁、条件变量。

### 2.用户态与内核态

​		用户态和内核态是操作系统的两种运行级别，当程序运行在R3特权级别的时候可以称为运行在用户态，在R0级别的时候可以成为运行在内核态。在用户态的级别只能访问受限的内存，且不允许访问外围IO设备等，只能使用非特权指令。而在内核态级别下可以访问内存中所有数据，包括外围IO设备。

​		应用程序大部分都是运行在用户态的状态之下，如果需要操作系统帮助完成某些在用户态完成不了的操作，便可以切换到内核态。用户态切换到内核态主要包括三种方式：

1.系统调用：操作系统在内核里都有一些内建的函数，这些函数可以完成一些系统级别的功能。比如fork指令调用的是sys_fork 

2.异常：当cpu在执行用户态的程序的时候发生了一些事先不可知的异常，则会切换到处理此异常的内核相关程序中，比如缺页异常。

3.外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，此时CPU会停止执行下一条指令而去处理中断，那么这个转换的过程就发生了由用户态向内核态的切换。

### 3. fork

​		fork是linux中用来创建与父进程相同的子进程的系统调用函数，它创建了一个原有进程的精确副本，包括所有文件描述符、寄存器等全部内容。

### 4.IO模型

​		3作系统有5种IO模型，分别是：

1.blocking IO：阻塞IO（BIO）

2.Non-blocking IO:非阻塞IO （NIO）

3.IO multiplexing:IO多路复用

4.signal driven IO：

5.asychronous IO:异步IO（AIO）

区别：

对于一个IO，会涉及到两个系统对象，调用这个IO的process和系统内核kernel。经历两个阶段：1.等待内核加载好所需数据。2.将数据从内核拷贝至进程之中。

BIO：当用户进程调用recvfrom系统调用，kernel开始准备数据，并且将数据从内核拷贝至用户空间，这个两个过程都是阻塞的。

NIO：当调用recvfrom时，如果kernel还没有准备好数据的时候会立即返回error，不会在第一阶段进行阻塞。

AIO：当进程执行read操作后，就可以开始做其他的事情了，不会产生任何阻塞，当内核准备好数据，且数据拷贝至用户空间之后才会通知，完全没有被阻塞。

[参考资料]:https://blog.csdn.net/historyasamirror/article/details/5778378

### 5.select poll 和epoll

 Linux通过socket睡眠队列来管理所有等待socket的某个事件的process，同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的process，通知process相关事件发生。

select：当用户线程调用select的时候，select会将所监控的文件描述符拷贝至内核空间，然后遍历，查看是否有可读事件，如果没有则接续睡眠，如果有则唤醒。这样有两个问题第一每次拷贝会造成性能损失，因此设置大小为1024。第二每次只要有一个数据可读都要遍历集合，效率低。

poll：poll解决了select大小限制的问题，使用了pollfd结构而不是select的fd_set结构。

epoll：首先应用内存映射的方式减少了每次都要把fd拷贝到内核空间的开销，其次使用红黑树的方式，组织fd集合，减少增删改的开销。并且引入一个双向链表作为单独的睡眠队列（因为一个进程要处理很多socket，因此此时睡眠的不是进程，而是对应的socket），解决了无效遍历的问题。并且epoll有两种触发模式，水平触发模式和边沿触发模式，区别在于水平触发模式是有数据可读一直触发，缓冲区不满一直触发。边沿触发模式是指当缓冲区状态发生改变的时候触发一次。

[]:(https://cloud.tencent.com/developer/article/1005481)

### 6.进程调度算法

答：常见的进程调度算法有：1.先来先服务。2.时间片轮转法。3.短作业优先调度。4.最短剩余时间优先：最短剩余时间是针对最短进程优先增加了抢占机制的版本)5.多级反馈队列:设置多个就绪队列，每个队列赋予不同的优先级，第一个队列最高，其余队列优先级逐次降低，在越高优先级的队列中时间片越小，当有一个新进程的时候首先放在最高优先级队尾，按照FCFS调度，如果能在一个时间片之内完成，则移除，否则进入下一优先级队列。

## Linux

### 1. chmod

​		chmod命令是用来更改文件权限的，分为三种权限：

1.写：w，权限值4

2.读：r，权限值2

3.执行：x，权限值1

其中按顺序分别表示，user、group和other的权限。例如：chmod741 表示user具有读写执行的权限，group具有写权限，other具有执行权限。

### 2.Linux 查看CPU和内存情况

​		top命令是Linux下常用的性能分析工具，能够显示系统中各个进程的资源占用情况。显示内容包括：用户占CPU百分比，内核占CPU百分比，空闲CPU，物理内存总量，使用内存总量等。

![img](https://img2018.cnblogs.com/blog/720994/201809/720994-20180918152552123-1390484337.png)



## Hadoop

### 1.hdfs小文件过多造成什么问题

答：首先小文件过多会在内存以对象的形式存储，这样会严重影响namenode的内存容量，制约集群的扩展性。其次访问大量小文件的速度远小于访问几个大文件，访问多个小文件就需要从不同的datanode中进行读取，严重影响速度。最后在处理小文件的时候大量时间花费在task的启停上，真正处理时间较小，影响效率。

### 2.Mapreduce join操作

答：

1.reduce side join：map阶段读取两个表，在reduce阶段进行shuffle，将具有同一个key的数据拉取到同一个reducer进行join操作。

2.map side join：这种情况适用于两个表中有一个表非常小的情况，可以将小表直接放入内存中使得每个map task内存中保存一份，避免shuffle的开销。

3.半连接：选取小表，将其参与join的key抽取出来，然后将这些key发送到map task的内存中，将不存在的key进行过滤，减少shuffle的数据量。



## 数据结构

### 1.跳表

答：跳表全称是跳跃链表，是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。一开始在最稀疏的层进行搜索，知道需要查找的元素在该层两个相信元素的中间，这时跳表转到下一层，继续刚才的搜索，知道找到相应元素为止。查找和插入的时间复杂度都是O(logN)，是一种拿空间换时间的数据结构。

### 2.布隆过滤器

答：布隆过滤器是一个很长的二进制向量和一系列随机映射函数。特点是高效的查询和插入，它可以用来告诉你某样东西一定不存在或者可能存在。如果我们要映射一个值到布隆过滤器中，就要使用多个映射函数生成多个哈希值，然后对每个哈希值指向的bit位置1。查询的时候逆向查询。

