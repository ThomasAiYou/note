# 面试 

## JVM

### 1.运行时的数据区域

答：JVM运行时数据区域大致分为5部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区。java8之后本地方法区变成了metaspace，放入了堆中。

​		程序计数器主要记录执行的字节码行号等信息，方便指令跳转。虚拟机栈是线程私有的，执行方法时创建栈帧存储局部变量，操作数，方法出口等信息。本地方法栈和虚拟机栈差不多，不过是为本地方法服务的。堆主要保存对象的实例。方法区主要保存类的信息，常量等。

### 2.垃圾回收机制

答：垃圾回收主要是在堆上，对于对象的实例分为新生代和老年代。同时新生代又分为1个Eden区域和2个Survivor区域，单个Eden：Survivor=8:1。新创建的对象主要生成在Eden区域，然后minor gc采用复制算法，达到一定次数以后进入老年区。

### 3.垃圾回收算法

答：主要垃圾回收算法包括：1.引用计数法；2.可达性分析法；3.标记-清理法；4.标记-整理法；5.复制法；6.分代收集法。

### 4.Minor GC和Full GC触发条件

答：Minor GC作用于新生代，当无法为新对象分配空间时发生Minor GC。Full GC是老年代，1.调用system.gc()；2.空间分配担保失败时候发生Full GC；3.新进大对象进入老年代超过内存大小发生

### 5.GC ROOT的起点都可以包括什么

答：1.虚拟机栈中直接引用的对象；2.方法区中类静态属性引用的变量；3.方法区中常量引用的变量

### 6.GC中的STW(stop the world)

答：stop the world 是指JVM运行过程中，除了垃圾收集线程，其他线程都被挂起的情况。Serial收集器，CMS收集器都会发生这种情况。

### 7.各个垃圾回收器的特点和区别

答：Serial/Serial Old收集器是单线程收集器，特点是简单快速，但是gc时会发生STW；ParNew收集器是Serial收集器的多线程版本，指垃圾收集是多线程的，也会发生STW，主要用于配合CMS收集器用作新生代收集器。Parallel/Parallel OLD 可控吞吐量。CMS最短时间为目标的老年代收集器分为4步初始标记、并发标记、重新标记、并发清除。除了初始标记和重新标记STW剩下多线程执行。缺点是CPU敏感、无法处理浮动垃圾、会产生碎片(标记清除)。G1收集器具有并发，分代，整合，可预测的特点，监控每个region，在有限时间收集价值最高的垃圾。

### 8.什么是Java内存模型

答：Java内存模型定义了JVM操作虚拟机时的工作方式，是对内存进行读写访问的过程抽象。

### 9.Java内存模型存在什么问题

答：Java每个线程都有单独的工作内存，他们不能够直接操作主存，因此会有线程之间的可见性问题，并且因为编译器会进行代码优化，所以也会有指令重排的问题。

### 10.volatile关键字是怎么实现的

答：volatile关键字是通过内存屏障来实现变量的可见性和防止指令重排。每次读volatile变量的时候都会使本地的工作内存无效化，直接从主存拷贝副本。每次写volatile变量都会立刻刷新到主存之中。

### 11.怎么理解内存屏障

答：内存屏障可以看作多线程之间的同步点，内存屏障之前的操作必须都进行完毕，并将变量值刷入主存后才能执行之后的内容，并且内存屏障内的代码不允许指令重排。

### 12.说几个先行发生原则

答：1.程序次序原则；2.管程锁定原则；3.volatile变量原则；4.线程启动原则

### 13.类加载过程

答：过程如下：

1.加载：主要是指通过类的全限定名称来获取定义此类的二进制字节流。

2.验证：验证的目的是为了确保字节流中包含的信息符合当前虚拟机的要求。

3.准备：正式为类变量分配内存，并设置类变量初始值的阶段。

4.解析：解析是虚拟机将常量池内的符号引用转换为直接引用的过程。

5.初始化：开始正式执行类中定义的Java程序代码。

6.使用：

7.卸载：

### 14.双亲委派模型

答：类加载器分为3类，分别是启动类加载器，扩展类加载器和应用程序类加载器。双亲委派模型要求除了启动类加载器外，剩下的类加载器都应当有自己的父类加载器。如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是委派给父类加载器去完成，只有父类无法完成时，子类加载器才会尝试自己去加载。

## SQL

### 1.SQL执行流程

![截屏2020-04-23下午4.39.11](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-23下午4.39.11-7631167.png)

答：1.客户端通过TCP连接发送连接请求到MySql连接器，连接器会对该请求进行权限验证以及连接资源分配。2.客户端发送一条语句，如果是select语句，在开启查询缓存的情况下，首先在查询缓存中查找该SQL是否完全匹配。3.如果在查询缓存中没有匹配成功，则将语句交给分析器做词法分析和语法分析。4.分析器分析的之后进入优化器，比如多个索引如何选择索引等。5.执行器调用引擎的接口，并返回调用的结果。

### 2.SQL的分类

答：SQL语句主要可以划分为以下三个类别：

1.DDL(Data Definition Languages)语句：数据定义语言。

2.DML(Data Manipulation Language)语句：数据操纵语句。

3.DCL(Data Control Language)语句：数据控制语句。

### 3.事物的基本要素

答：ACID。A：原子性，所有操作都是原子操作。C：一致性，事物必须保持系统处于一致的状态。I：隔离性，保证事物之间是相互隔离的。D：事务完成之后，便被持久化到磁盘之中，不会被更改。

### 4.事物的隔离级别

答：Read Uncommitted，Read Committed，Repeated Read, Serializable

### 5.InnoDB和MyISAM的区别

答：MyISAM和InnoDB都是MySQL的存储引擎。区别主要在MyISAM不是事务安全的，没有外键，且MyISAM只支持表锁。InnoDB支持事物和行锁。同时MyISAM和InnoDB的索引也有所不同，MyISAM使用的是非聚集索引，InnoDB使用的聚集索引。

### 6.MVCC

答：MVCC的目的是并发访问数据库时，对正在事务内处理的数据做多版本的管理。以达到用来避免写操作的拥塞

## 多线程

### 1.线程的几种状态

答：线程有6种状态，分别是:New:刚刚创建的线程、Runnable:准备就绪、Waiting:无时间限制等待、Blocked:被阻塞，比如synchronized同步块、Timed_waiting限时等待和Terminated:结束。

### 2.线程创建的方式

答：线程创建有三种方式：

1.继承Thread类，重写run方法，使用start()方法来启动线程。

2.实现Runnable接口，重写run方法，使用start()方法来启动线程。

3.通过Callable和Future创建线程，实现Callable接口，实现call()方法

### 3.线程池的种类

答：为了避免频繁的创建和销毁线程，让线程复用可以创建线程池。线程池主要有以下几种：

1.newFixedThreadPool:返回一个固定数量的线程池。

2.newSingleThreadExecutor:返回一个只有一个线程的线程池。

3.newCachedThreadPool:返回一个可以根据实际情况调整线程数量的线程池。

4.newSingleThreadScheduledExecutor和newScheduledThreadPool:扩展了在给定时间执行任务的功能。

### 4.线程池的内部实现

答：上面的线程池都是ThreadPoolExecutor的封装类。

![截屏2020-04-24下午3.32.43](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-24下午3.32.43.png)

任务队列：

1.直接提交队列：每来一个任务都直接提交，超过了最大线程数量，执行拒绝策略。

2.有界任务队列：ArrayBlockingQueue来实现的，有最大容量限制。

3.无界任务队列：LinkedBlockingQueue来实现的，无最大容量限制。

4.优先级队列：PriorityBlockingQueue来实现，根据任务优先级来执行。

拒绝策略：

1.AbortPolicy策略：该策略直接抛出异常，阻止系统正常运行。

2.CallerRunsPolicy：只要线程池未关闭，直接在调用者线程中，运行当前任务。提交线程性能下降。

3.DiscardOldest:抛弃最老的请求。

4.DiscardPolicy：抛弃无法处理的这个请求。

### 5.wait和sleep的区别

答：sleep属于Thread类，表示让一个线程进入睡眠状态，等待一段时间以后自动唤醒，没有释放锁。wait属于object，释放了锁，如果设置了超时时间并不需要其他线程使用notify方法也能解除阻塞。否则需要调用notify方法。



## 计算机网络

### 1.HTTP请求方法

答：Http有八种请求方法分别是：GET：请求页面信息、HEAD：获取报头、POST：提交数据进行请求处理、PUT：传送数据、DELETE：删除指定页面、CONNECT预留能将连接改为管道方式的代理服务器、OPTIONS：查看主机性能、TRACE：显示服务器收到的请求，用于诊断。

### 2.键入URL对应过程

答：过程如下：

1.客户端连接到HTTP服务器：浏览器与WEB服务器的HTTP端口(默认是80端口)建立TCP套接字连接。

2.发送HTTP请求：通过TCP套接字，客户端向服务器发送请求报文，包括请求行、请求头部、空行和请求数据4部分。

3.服务器接受请求并返回HTTP相应：WEB服务器解析请求，定位资源，将资源副本写到TCP套接字，返回响应。响应由状态行、响应头部、空行和响应数据4部分组成。

4.释放TCP连接：

5.客户端浏览器解析响应内容，在浏览器窗口显示。

### 3.常用状态码

答：200:OK、404:NOT FOUND，资源不存在、400:BAD REQUEST，参数无效、403:FORBIDDEN客户端错误



## JAVA

### 1.ArrayList和LinkedList区别

答：区别如下：

1.ArrayList是基于数组的数据结构，LinkedList是基于链表的数据结构。

2.对于随机访问的方法ArrayList优于LinkedList，因为数组支持随机访问，LinkedList要移动指针。

3.对于插入删除数据操作LinkedList要优于ArrayList，因为ArrayList要移动数据。

### 2.Exception的父类，几种错误

![截屏2020-04-24下午4.18.42](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-24下午4.18.42.png)

### 3.锁

1.公平锁/非公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的顺序来获得锁。公平锁的好处是线程不会饿死，但效率较低一些。因为非公平锁某时刻可能不需要唤醒线程，抢占。

2.重入锁：如果当前线程已经拥有了对象的锁，只需要把锁的计数器+1，便可以直接进入临界区，避免一定程度避免死锁的出现。

3.重量级锁：Java线程要映射到操作系统原生线程之上，因此如果阻塞和唤醒线程需要从用户态转到核心态。因此需要这种转换的锁称为重量级锁。

4.偏向锁：偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步(不需要CAS与内存中的预期值进行比较)。

按照竞争条件分为：无锁<偏向锁<轻量级锁<重量级锁

### 4.Hash、HashMap、HashTable、ConcurrentHashMap

#### Hash

答：Hash就是把任意长度读输入，通过散列算法，变成固定长度的输出，该输出就是散列值。

#### Hash冲突的处理方式

答：Hash冲突的处理方法有以下几种：

1.开放地址法(线性探查)：当冲突发生时候，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个序列一次查找下去，当碰到一个空单元的时候，插入其中。

2.拉链法：冲突发生的时候，使用链表存储散列值相同的元素。

3.建立公共溢出区域：把冲突放在另一个公共溢出区中。

4.再Hash方法：计算散列值方法不止一个，如果有冲突发生再次计算散列值。

#### HashTable

答：HashTable是线程安全的，只不过效率很差，因为直接在put方法上使用sychronized关键字，会锁定整张表。键值不允许为null。

#### HashMap

答：Hashmap底层由数组+链表实现，不是线程安全的。

1.初始大小:16，初始负载因子:0.75，

2.红黑树转换：满足两个条件1:当hashMap的capacity大于等于64的时候，且链表长度等于8的时候进行扩容。

![截屏2020-04-25上午9.44.05](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午9.44.05.png)

3.Hash算法：算出hashCode右移16位做异或运算(相同为0不同为1)

![截屏2020-04-25上午9.25.12](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午9.25.12.png)

4.resize()为什么是2的倍数。1.2的n次方-1的二进制数字全部都是1，在与hash值做&运算的时候能够最大程度的进行散列。

![截屏2020-04-25上午10.08.53](/Users/denakira/Desktop/myworkspace/note/面试/picture/截屏2020-04-25上午10.08.53.png)

#### ConcurrentHashMap

答：在Java8之前ConcurrentHashMap时使用分段锁来实现并发的，数据结构为hashMap的基础上再套一层segment数组，锁加在segment数组元素上。Java8实现了更加细粒度的锁，去掉了segment数组，直接使用synchronized锁住了hash后得到的数组下标位置中的第一个元素。这样比segment锁支持更高的并发度。

## Elasticsearch

